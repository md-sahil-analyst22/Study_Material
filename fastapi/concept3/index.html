<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complete Uvicorn & Swagger Study Guide - Full Stack Development</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #3498db;
            --secondary: #2ecc71;
            --accent: #e74c3c;
            --dark: #2c3e50;
            --light: #ecf0f1;
            --gray: #95a5a6;
            --code-bg: #1e1e1e;
            --code-text: #d4d4d4;
            --success: #27ae60;
            --warning: #f39c12;
            --info: #16a085;
            --danger: #c0392b;
        }

        html {
            scroll-behavior: smooth;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--dark);
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            background-attachment: fixed;
        }

        /* Scrollbar Styling */
        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }

        ::-webkit-scrollbar-thumb {
            background: var(--primary);
            border-radius: 5px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--secondary);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 0 20px;
        }

        /* Header & Navigation */
        header {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 30px 0;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            position: sticky;
            top: 0;
            z-index: 1000;
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 20px;
        }

        .logo {
            font-size: 28px;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .logo-icon {
            font-size: 32px;
        }

        nav {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        nav a {
            color: white;
            text-decoration: none;
            padding: 8px 15px;
            border-radius: 5px;
            transition: background 0.3s ease;
            font-size: 14px;
        }

        nav a:hover {
            background: rgba(255,255,255,0.2);
        }

        /* Table of Contents */
        .toc {
            background: white;
            padding: 30px;
            border-radius: 10px;
            margin: 30px auto;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            max-width: 900px;
        }

        .toc h2 {
            color: var(--primary);
            margin-bottom: 20px;
            font-size: 24px;
        }

        .toc-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
        }

        .toc-item {
            padding: 15px;
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            border-left: 4px solid var(--primary);
            border-radius: 5px;
            cursor: pointer;
            transition: transform 0.3s ease, box-shadow 0.3s ease;
        }

        .toc-item:hover {
            transform: translateX(10px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .toc-item a {
            color: var(--dark);
            text-decoration: none;
            font-weight: 600;
            display: block;
        }

        /* Main Content */
        .content {
            background: white;
            padding: 40px;
            border-radius: 10px;
            margin: 30px auto;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
            max-width: 1100px;
        }

        section {
            margin-bottom: 50px;
            padding-bottom: 30px;
            border-bottom: 2px solid var(--light);
        }

        section:last-child {
            border-bottom: none;
        }

        h1 {
            font-size: 36px;
            color: var(--primary);
            margin-bottom: 30px;
            text-align: center;
            position: relative;
            padding-bottom: 15px;
        }

        h1::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            transform: translateX(-50%);
            width: 60px;
            height: 3px;
            background: var(--secondary);
        }

        h2 {
            font-size: 28px;
            color: var(--secondary);
            margin: 30px 0 20px 0;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h2::before {
            content: '‚ñ∂';
            color: var(--primary);
            font-size: 20px;
        }

        h3 {
            font-size: 22px;
            color: var(--dark);
            margin: 20px 0 15px 0;
        }

        h4 {
            font-size: 18px;
            color: var(--primary);
            margin: 15px 0 10px 0;
        }

        p {
            margin-bottom: 15px;
            text-align: justify;
            line-height: 1.8;
        }

        /* Highlight Boxes */
        .highlight {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1) 0%, rgba(46, 204, 113, 0.1) 100%);
            border-left: 5px solid var(--primary);
            padding: 20px;
            margin: 20px 0;
            border-radius: 5px;
        }

        .highlight.success {
            background: linear-gradient(135deg, rgba(39, 174, 96, 0.1) 0%, rgba(46, 204, 113, 0.1) 100%);
            border-left-color: var(--success);
        }

        .highlight.warning {
            background: linear-gradient(135deg, rgba(243, 156, 18, 0.1) 0%, rgba(244, 208, 63, 0.1) 100%);
            border-left-color: var(--warning);
        }

        .highlight.danger {
            background: linear-gradient(135deg, rgba(192, 57, 43, 0.1) 0%, rgba(231, 76, 60, 0.1) 100%);
            border-left-color: var(--danger);
        }

        .highlight.info {
            background: linear-gradient(135deg, rgba(22, 160, 133, 0.1) 0%, rgba(26, 188, 156, 0.1) 100%);
            border-left-color: var(--info);
        }

        /* Code Blocks */
        pre {
            background: var(--code-bg);
            color: var(--code-text);
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            border-left: 4px solid var(--primary);
            box-shadow: inset 0 2px 8px rgba(0,0,0,0.2);
            font-family: 'Courier New', monospace;
            font-size: 13px;
            line-height: 1.5;
        }

        code {
            background: var(--code-bg);
            color: var(--secondary);
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }

        pre code {
            background: none;
            color: var(--code-text);
            padding: 0;
        }

        /* Tables */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            overflow: hidden;
            border-radius: 8px;
        }

        thead {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
        }

        th, td {
            padding: 15px;
            text-align: left;
            border-bottom: 1px solid var(--light);
        }

        tbody tr:hover {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1) 0%, rgba(46, 204, 113, 0.1) 100%);
            transition: background 0.3s ease;
        }

        /* Lists */
        ul, ol {
            margin: 20px 0 20px 30px;
            line-height: 2;
        }

        li {
            margin-bottom: 10px;
        }

        li strong {
            color: var(--primary);
        }

        /* Feature Badges */
        .badge {
            display: inline-block;
            padding: 5px 12px;
            background: var(--primary);
            color: white;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            margin: 5px 5px 5px 0;
        }

        .badge.secondary {
            background: var(--secondary);
        }

        .badge.warning {
            background: var(--warning);
        }

        .badge.danger {
            background: var(--danger);
        }

        /* Cards */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .card {
            background: white;
            border: 2px solid var(--light);
            border-radius: 8px;
            padding: 20px;
            transition: transform 0.3s ease, box-shadow 0.3s ease, border-color 0.3s ease;
            cursor: pointer;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0,0,0,0.15);
            border-color: var(--primary);
        }

        .card h3 {
            color: var(--primary);
            margin-bottom: 10px;
        }

        .card p {
            font-size: 14px;
            color: var(--gray);
        }

        /* Comparison Table */
        .comparison-table {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .comparison-col {
            background: white;
            padding: 25px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.12);
            transition: transform 0.3s ease, box-shadow 0.3s ease;
            border-top: 5px solid var(--primary);
        }

        .comparison-col:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 25px rgba(0,0,0,0.15);
        }

        .comparison-col h4 {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 12px 15px;
            border-radius: 6px;
            margin: 0 0 15px 0;
            font-size: 18px;
            font-weight: 600;
            text-align: center;
            letter-spacing: 0.5px;
        }

        .comparison-col p {
            font-size: 15px;
            line-height: 1.7;
            margin-bottom: 12px;
            color: var(--dark);
        }

        .comparison-col pre {
            background: var(--code-bg);
            color: var(--code-text);
            padding: 15px;
            border-radius: 6px;
            font-size: 12px;
            line-height: 1.4;
            overflow-x: auto;
            border-left: 3px solid var(--primary);
            margin: 15px 0;
        }

        .comparison-col pre code {
            font-size: 12px;
            line-height: 1.4;
        }

        /* Diagrams */
        .diagram {
            background: white;
            border: 2px solid var(--primary);
            padding: 30px;
            border-radius: 8px;
            margin: 30px 0;
            text-align: center;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .diagram img {
            max-width: 100%;
            height: auto;
            border-radius: 5px;
        }

        .flow-diagram {
            display: flex;
            align-items: center;
            justify-content: space-around;
            flex-wrap: wrap;
            gap: 20px;
            margin: 30px 0;
            padding: 20px;
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1) 0%, rgba(46, 204, 113, 0.1) 100%);
            border-radius: 8px;
        }

        .flow-item {
            background: white;
            padding: 15px 25px;
            border-radius: 5px;
            border: 2px solid var(--primary);
            font-weight: bold;
            color: var(--dark);
            text-align: center;
            flex: 1;
            min-width: 150px;
        }

        .flow-arrow {
            font-size: 28px;
            color: var(--primary);
        }

        /* USP Section */
        .usp-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }

        .usp-item {
            background: linear-gradient(135deg, rgba(52, 152, 219, 0.1) 0%, rgba(46, 204, 113, 0.1) 100%);
            padding: 25px;
            border-radius: 8px;
            border-left: 5px solid var(--primary);
            transition: transform 0.3s ease;
        }

        .usp-item:hover {
            transform: translateY(-5px);
        }

        .usp-icon {
            font-size: 32px;
            margin-bottom: 10px;
        }

        .usp-item h4 {
            margin: 10px 0;
        }

        /* Pros & Cons */
        .pros-cons-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .pros, .cons {
            padding: 20px;
            border-radius: 8px;
            background: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }

        .pros {
            border-top: 4px solid var(--success);
        }

        .cons {
            border-top: 4px solid var(--danger);
        }

        .pros h4, .cons h4 {
            margin-top: 0;
        }

        .pros h4 {
            color: var(--success);
        }

        .cons h4 {
            color: var(--danger);
        }

        .pros ul, .cons ul {
            margin-left: 20px;
        }

        .pros li::marker {
            color: var(--success);
        }

        .cons li::marker {
            color: var(--danger);
        }

        /* Use Cases */
        .use-case-item {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-left: 5px solid var(--primary);
            border-radius: 5px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.3s ease;
        }

        .use-case-item:hover {
            transform: translateX(5px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .use-case-item strong {
            color: var(--primary);
            font-size: 16px;
        }

        /* Footer */
        footer {
            background: var(--dark);
            color: white;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
        }

        footer p {
            margin: 5px 0;
            text-align: center;
        }

        /* Responsive */
        @media (max-width: 1200px) {
            .comparison-table {
                grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
                gap: 20px;
            }

            .comparison-col {
                padding: 20px;
            }

            .comparison-col h4 {
                font-size: 16px;
            }

            .comparison-col pre {
                font-size: 11px;
            }
        }

        @media (max-width: 768px) {
            header {
                padding: 20px 0;
            }

            .header-content {
                flex-direction: column;
                gap: 15px;
            }

            nav {
                justify-content: center;
            }

            h1 {
                font-size: 28px;
            }

            h2 {
                font-size: 22px;
            }

            .toc-grid {
                grid-template-columns: 1fr;
            }

            .comparison-table {
                grid-template-columns: 1fr;
                gap: 20px;
                margin: 25px 0;
            }

            .comparison-col {
                padding: 20px;
                border-top: 4px solid var(--primary);
            }

            .comparison-col h4 {
                font-size: 16px;
                margin: 0 0 12px 0;
                padding: 10px;
            }

            .comparison-col p {
                font-size: 14px;
            }

            .comparison-col pre {
                font-size: 11px;
                padding: 12px;
                margin: 12px 0;
            }

            .pros-cons-grid {
                grid-template-columns: 1fr;
            }

            .flow-diagram {
                flex-direction: column;
                gap: 15px;
            }

            .flow-arrow {
                transform: rotate(90deg);
                font-size: 24px;
            }

            .flow-item {
                min-width: 100%;
                flex: 1 1 100%;
            }

            pre {
                font-size: 11px;
                padding: 15px;
                margin: 15px 0;
            }

            table {
                font-size: 13px;
            }

            th, td {
                padding: 10px;
            }

            .content {
                padding: 20px;
            }

            .usp-grid {
                grid-template-columns: 1fr;
            }

            .card-grid {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            h1 {
                font-size: 22px;
            }

            h2 {
                font-size: 18px;
            }

            h3 {
                font-size: 16px;
            }

            nav {
                flex-direction: column;
                gap: 10px;
            }

            nav a {
                padding: 10px;
                display: block;
                text-align: center;
            }

            .logo {
                font-size: 20px;
            }

            .logo-icon {
                font-size: 24px;
            }

            pre {
                font-size: 10px;
            }

            ul, ol {
                margin-left: 15px;
            }
        }

        /* Print Styles */
        @media print {
            header {
                position: static;
            }

            .toc {
                break-inside: avoid;
            }

            section {
                break-inside: avoid;
            }

            .flow-diagram {
                break-inside: avoid;
            }

            table {
                break-inside: avoid;
            }
        }

        /* Animations */
        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .content {
            animation: slideIn 0.5s ease;
        }

        /* Scrollspy Indicator */
        .scrollspy {
            position: fixed;
            right: 20px;
            bottom: 20px;
            width: 50px;
            height: 50px;
            background: var(--primary);
            color: white;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            z-index: 999;
            transition: background 0.3s ease;
            text-align: center;
            font-size: 24px;
        }

        .scrollspy:hover {
            background: var(--secondary);
        }

        @media (max-width: 768px) {
            .scrollspy {
                width: 45px;
                height: 45px;
                right: 15px;
                bottom: 15px;
            }
        }
    </style>
</head>
<body>
    <!-- Header -->
    <header>
        <div class="container">
            <div class="header-content">
                <div class="logo">
                    <span class="logo-icon">‚ö°</span>
                    <span>Uvicorn & Swagger</span>
                </div>
                <nav>
                    <a href="#overview">Overview</a>
                    <a href="#uvicorn">Uvicorn</a>
                    <a href="#swagger">Swagger</a>
                    <a href="#architecture">Architecture</a>
                    <a href="#usps">USPs</a>
                    <a href="#alternatives">Alternatives</a>
                    <a href="#future">Future</a>
                </nav>
            </div>
        </div>
    </header>

    <!-- Table of Contents -->
    <div class="container">
        <div class="toc">
            <h2>üìö Complete Study Guide Contents</h2>
            <div class="toc-grid">
                <div class="toc-item">
                    <a href="#overview">üéØ Executive Overview</a>
                    <p style="font-size: 12px; margin: 5px 0 0 0;">Key concepts and introduction</p>
                </div>
                <div class="toc-item">
                    <a href="#module0">üìñ Module 0: Fundamentals</a>
                    <p style="font-size: 12px; margin: 5px 0 0 0;">Server, API, HTTP, JSON basics</p>
                </div>
                <div class="toc-item">
                    <a href="#module1">‚öôÔ∏è Module 1: Uvicorn Basics</a>
                    <p style="font-size: 12px; margin: 5px 0 0 0;">Installation, ASGI, async concepts</p>
                </div>
                <div class="toc-item">
                    <a href="#module2">üîß Module 2: Advanced Topics</a>
                    <p style="font-size: 12px; margin: 5px 0 0 0;">Middleware, event loops, production</p>
                </div>
                <div class="toc-item">
                    <a href="#module3">üìã Module 3: Swagger/OpenAPI</a>
                    <p style="font-size: 12px; margin: 5px 0 0 0;">Documentation and specifications</p>
                </div>
                <div class="toc-item">
                    <a href="#integration">üîó Integration Patterns</a>
                    <p style="font-size: 12px; margin: 5px 0 0 0;">Real-world examples and use cases</p>
                </div>
                <div class="toc-item">
                    <a href="#performance">‚ö° Performance & Optimization</a>
                    <p style="font-size: 12px; margin: 5px 0 0 0;">Tuning and best practices</p>
                </div>
                <div class="toc-item">
                    <a href="#usps">‚≠ê USPs & Comparisons</a>
                    <p style="font-size: 12px; margin: 5px 0 0 0;">Strengths and market position</p>
                </div>
                <div class="toc-item">
                    <a href="#alternatives">üîÑ Alternatives & Competitors</a>
                    <p style="font-size: 12px; margin: 5px 0 0 0;">Other frameworks and solutions</p>
                </div>
                <div class="toc-item">
                    <a href="#future">üöÄ Future Roadmap</a>
                    <p style="font-size: 12px; margin: 5px 0 0 0;">Emerging trends and evolution</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="container">
        <div class="content">

            <!-- OVERVIEW SECTION -->
            <section id="overview">
                <h1>‚ö° Complete Uvicorn & Swagger Study Guide</h1>
                <p style="text-align: center; font-size: 16px; color: var(--gray); margin-bottom: 30px;">
                    A comprehensive deep-dive into modern Python ASGI web servers, async programming, and API documentation
                </p>

                <div class="highlight success">
                    <strong>üéì What You'll Learn:</strong>
                    <ul style="margin: 10px 0 0 20px;">
                        <li>üîπ Why Uvicorn is the modern replacement for WSGI servers</li>
                        <li>üîπ How to build lightning-fast asynchronous APIs with FastAPI + Uvicorn</li>
                        <li>üîπ Complete Swagger/OpenAPI specification and documentation</li>
                        <li>üîπ Production-ready deployment patterns and performance tuning</li>
                        <li>üîπ Real-world architectural patterns and use cases</li>
                        <li>üîπ Security, authentication, and error handling best practices</li>
                        <li>üîπ Comparing with alternatives and understanding market trends</li>
                    </ul>
                </div>

                <h2>What is Uvicorn & Swagger?</h2>
                <p>
                    <strong>Uvicorn</strong> is a lightning-fast ASGI (Asynchronous Server Gateway Interface) server written in Python. 
                    It enables building high-performance, asynchronous web applications with support for HTTP, WebSocket, and HTTP/2 protocols.
                </p>
                <p>
                    <strong>Swagger/OpenAPI</strong> is a specification and set of tools for describing RESTful APIs in a machine-readable format. 
                    It enables automatic interactive documentation generation, client SDK generation, and API validation directly from your code.
                </p>

                <h2>Quick Comparison: WSGI vs ASGI</h2>
                <table>
                    <thead>
                        <tr>
                            <th>Feature</th>
                            <th>WSGI (Old)</th>
                            <th>ASGI (New) with Uvicorn</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Protocol Support</strong></td>
                            <td>HTTP only</td>
                            <td>HTTP, WebSocket, HTTP/2</td>
                        </tr>
                        <tr>
                            <td><strong>Concurrency Model</strong></td>
                            <td>Synchronous (threads/processes)</td>
                            <td>Asynchronous (async/await)</td>
                        </tr>
                        <tr>
                            <td><strong>Performance</strong></td>
                            <td>Good for traditional apps</td>
                            <td>Excellent for I/O-heavy operations</td>
                        </tr>
                        <tr>
                            <td><strong>Memory Footprint</strong></td>
                            <td>Higher per connection</td>
                            <td>Lower, more efficient</td>
                        </tr>
                        <tr>
                            <td><strong>Real-time Features</strong></td>
                            <td>Not supported</td>
                            <td>WebSocket support</td>
                        </tr>
                        <tr>
                            <td><strong>Examples</strong></td>
                            <td>Gunicorn, uWSGI, Django</td>
                            <td>Uvicorn, Hypercorn, Daphne</td>
                        </tr>
                    </tbody>
                </table>
            </section>

            <!-- MODULE 0: FUNDAMENTALS -->
            <section id="module0">
                <h2>Module 0: Absolute Fundamentals for Beginners</h2>
                <p>
                    Before diving into Uvicorn and Swagger, you must understand the foundational concepts that power modern web development.
                </p>

                <h3>0.1 What is a Server and Backend?</h3>
                <div class="flow-diagram">
                    <div class="flow-item">Browser<br/>(Frontend)</div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-item">HTTP Request<br/>("GET /todos")</div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-item">Python Backend<br/>(FastAPI)</div>
                    <div class="flow-arrow">‚Üí</div>
                    <div class="flow-item">Database<br/>& Logic</div>
                </div>
                <div class="highlight info">
                    <strong>Simple Definition:</strong>
                    <ul>
                        <li><strong>Frontend</strong> = What users see (HTML, CSS, JS in browser)</li>
                        <li><strong>Backend</strong> = Python program running on a machine, listening for requests</li>
                        <li><strong>Server</strong> = The machine + software that serves your backend responses</li>
                    </ul>
                </div>

                <h3>0.2 API, HTTP, and JSON</h3>
                <div class="card-grid">
                    <div class="card">
                        <h4>üîó API</h4>
                        <p>Application Programming Interface. A set of rules about how software can talk to other software.</p>
                    </div>
                    <div class="card">
                        <h4>üì° HTTP</h4>
                        <p>Protocol of the web. Uses methods: GET, POST, PUT, DELETE, PATCH. Status codes: 200, 404, 500, etc.</p>
                    </div>
                    <div class="card">
                        <h4>üìÑ JSON</h4>
                        <p>Text format for data transfer. Example: {"id": 1, "name": "Laptop", "price": 49999}</p>
                    </div>
                </div>

                <h3>0.3 HTTP Status Codes Quick Reference</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Code</th>
                            <th>Name</th>
                            <th>Meaning</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>200</strong></td>
                            <td>OK</td>
                            <td>Request succeeded</td>
                        </tr>
                        <tr>
                            <td><strong>201</strong></td>
                            <td>Created</td>
                            <td>New resource created successfully</td>
                        </tr>
                        <tr>
                            <td><strong>400</strong></td>
                            <td>Bad Request</td>
                            <td>Client sent invalid data</td>
                        </tr>
                        <tr>
                            <td><strong>401</strong></td>
                            <td>Unauthorized</td>
                            <td>No or invalid authentication</td>
                        </tr>
                        <tr>
                            <td><strong>404</strong></td>
                            <td>Not Found</td>
                            <td>Resource doesn't exist</td>
                        </tr>
                        <tr>
                            <td><strong>500</strong></td>
                            <td>Server Error</td>
                            <td>Bug or failure in server</td>
                        </tr>
                    </tbody>
                </table>

                <h3>0.4 Localhost & Ports</h3>
                <div class="highlight warning">
                    <strong>Understanding http://127.0.0.1:8000</strong>
                    <ul>
                        <li><strong>127.0.0.1</strong> = localhost = "this machine itself"</li>
                        <li><strong>:8000</strong> = port number. One machine can run many servers on different ports (8000, 8001, 3000, 5432, etc.)</li>
                        <li>When Uvicorn runs on port 8000, your browser connects to that port locally</li>
                    </ul>
                </div>

                <h3>0.5 Restaurant Analogy (Easy to Remember)</h3>
                <div class="diagram">
                    <strong style="display: block; margin-bottom: 15px;">How APIs work - A Restaurant Model</strong>
                    <div class="flow-diagram">
                        <div class="flow-item">Customer<br/>(Browser)</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-item">Places Order<br/>(HTTP Request)</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-item">Waiter<br/>(Uvicorn)</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-item">Kitchen<br/>(FastAPI)</div>
                        <div class="flow-arrow">‚Üí</div>
                        <div class="flow-item">Database<br/>(Inventory)</div>
                    </div>
                    <p style="margin-top: 15px; font-style: italic;">
                        <strong>Swagger</strong> = nicely printed menu explaining all dishes (endpoints)
                    </p>
                </div>
            </section>

            <!-- MODULE 1: UVICORN BASICS -->
            <section id="module1">
                <h2>Module 1: Uvicorn Fundamentals</h2>

                <h3>1.1 What is ASGI?</h3>
                <p>
                    <strong>ASGI = Asynchronous Server Gateway Interface</strong>. It's the modern standard interface that web applications use to talk to servers.
                </p>
                <div class="highlight">
                    <strong>Key Differences:</strong>
                    <ul>
                        <li><strong>WSGI</strong> (old) = could only handle synchronous HTTP</li>
                        <li><strong>ASGI</strong> (new) = handles async HTTP, WebSockets, long-living connections</li>
                    </ul>
                </div>

                <h3>1.2 Installation & First Server</h3>
                <pre><code># Step 1: Install Uvicorn
pip install "uvicorn[standard]"

# Step 2: Install FastAPI (recommended)
pip install fastapi

# Step 3: Verify installation
uvicorn --version</code></pre>

                <pre><code>from fastapi import FastAPI

app = FastAPI(
    title="My First API",
    description="Hello world example",
    version="1.0.0"
)

@app.get("/")
async def root():
    return {"message": "Hello, World!"}

@app.get("/items/{item_id}")
async def read_item(item_id: int, q: str = None):
    return {"item_id": item_id, "query": q}</code></pre>

                <h3>1.3 Running the Server</h3>
                <pre><code># Method 1: Using Python directly
python app.py

# Method 2: Using uvicorn CLI
uvicorn app:app --host 0.0.0.0 --port 8000

# Method 3: With auto-reload (development)
uvicorn app:app --reload

# Method 4: With multiple workers (production)
uvicorn app:app --workers 4

# Method 5: With SSL/HTTPS
uvicorn app:app --ssl-keyfile=key.pem --ssl-certfile=cert.pem</code></pre>

                <div class="highlight success">
                    <strong>After running:</strong>
                    <ul>
                        <li>Visit <code>http://localhost:8000</code> ‚Üí See your API response</li>
                        <li>Visit <code>http://localhost:8000/docs</code> ‚Üí Interactive Swagger UI</li>
                        <li>Visit <code>http://localhost:8000/redoc</code> ‚Üí ReDoc documentation</li>
                        <li>Visit <code>http://localhost:8000/openapi.json</code> ‚Üí Raw OpenAPI spec</li>
                    </ul>
                </div>

                <h3>1.4 Uvicorn Configuration Parameters</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Parameter</th>
                            <th>Default</th>
                            <th>Description</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><code>host</code></td>
                            <td>127.0.0.1</td>
                            <td>Bind address (0.0.0.0 for all interfaces)</td>
                        </tr>
                        <tr>
                            <td><code>port</code></td>
                            <td>8000</td>
                            <td>TCP port to listen on</td>
                        </tr>
                        <tr>
                            <td><code>workers</code></td>
                            <td>1</td>
                            <td>Number of worker processes</td>
                        </tr>
                        <tr>
                            <td><code>reload</code></td>
                            <td>False</td>
                            <td>Auto-restart on code changes (dev only)</td>
                        </tr>
                        <tr>
                            <td><code>ssl_keyfile</code></td>
                            <td>None</td>
                            <td>Path to SSL key file</td>
                        </tr>
                        <tr>
                            <td><code>ssl_certfile</code></td>
                            <td>None</td>
                            <td>Path to SSL certificate file</td>
                        </tr>
                        <tr>
                            <td><code>log_level</code></td>
                            <td>info</td>
                            <td>Logging level (debug, info, warning, error)</td>
                        </tr>
                    </tbody>
                </table>

                <h3>1.5 Sync vs Async (Critical Concept)</h3>
                <div class="highlight info" style="margin-bottom: 20px;">
                    <strong>‚ö° Understanding the Difference:</strong>
                    <p>This is one of the most critical concepts in Uvicorn. Synchronous code blocks the worker thread, preventing other requests from being handled. Asynchronous code yields control back to the event loop, allowing thousands of concurrent requests to be processed efficiently.</p>
                </div>
                
                <div class="comparison-table">
                    <div class="comparison-col">
                        <h4>‚ùå Synchronous (Blocking)</h4>
                        <pre><code>@app.get("/slow")
def slow_sync():
    time.sleep(5)
    return {
        "msg": "done",
        "duration": 5
    }</code></pre>
                        <p><strong>What happens:</strong> The worker thread is completely blocked for 5 seconds. Other requests must wait in queue.</p>
                        <p><strong>Concurrency:</strong> Low - can only handle 1 request at a time per worker</p>
                        <p><strong>Memory:</strong> Higher - needs separate thread/process per request</p>
                    </div>
                    <div class="comparison-col">
                        <h4>‚úÖ Asynchronous (Non-blocking)</h4>
                        <pre><code>@app.get("/fast")
async def fast_async():
    await asyncio.sleep(5)
    return {
        "msg": "done",
        "duration": 5
    }</code></pre>
                        <p><strong>What happens:</strong> Event loop parks this request and processes others while waiting.</p>
                        <p><strong>Concurrency:</strong> High - handles 1000s of concurrent requests</p>
                        <p><strong>Memory:</strong> Lower - single event loop handles all requests</p>
                    </div>
                    <div class="comparison-col">
                        <h4>üìä Visual: How They Handle 3 Requests</h4>
                        <pre><code><strong>SYNC (Sequential):</strong>
Request A: [====5s====]
Request B:           [====5s====]
Request C:                    [====5s====]
Total: 15 seconds


<strong>ASYNC (Concurrent):</strong>
Request A: [====5s====]
Request B: [====5s====]
Request C: [====5s====]
Total: ~5 seconds!</code></pre>
                    </div>
                </div>

                <div class="highlight warning">
                    <strong>üéØ Rule of Thumb:</strong>
                    <ul>
                        <li>‚úÖ Use <code>async def</code> for I/O-bound operations (database queries, API calls, file I/O)</li>
                        <li>‚úÖ Use <code>async def</code> for waiting operations (timeouts, delays, external services)</li>
                        <li>‚ö†Ô∏è Use <code>def</code> (sync) only for pure computation that completes quickly (rare in APIs)</li>
                        <li>‚ö° <strong>Uvicorn excels with async</strong> because it can handle 1000s of concurrent requests on a single thread using the event loop</li>
                    </ul>
                </div>

                <div class="highlight success">
                    <strong>üí° Real-World Performance Impact:</strong>
                    <ul>
                        <li>Sync server with 1 worker: ~1,000 requests/second (thread per request model)</li>
                        <li>Async Uvicorn with 1 worker: ~10,000+ requests/second (event loop model)</li>
                        <li>Async Uvicorn with 4 workers: ~40,000+ requests/second (multiplied across cores)</li>
                    </ul>
                </div>
            </section>

            <!-- MODULE 2: ADVANCED TOPICS -->
            <section id="module2">
                <h2>Module 2: Advanced Uvicorn Topics</h2>

                <h3>2.1 ASGI Call Flow Diagram</h3>
                <div class="diagram">
                    <img src="https://user-gen-media-assets.s3.amazonaws.com/seedream_images/bffcd394-d740-4f07-b3bb-db7d0e04cb89.png" alt="Uvicorn Architecture">
                </div>

                <h3>2.2 Middleware & Cross-Cutting Concerns</h3>
                <p>
                    Middleware wraps your app to add behavior like logging, authentication, CORS, rate limiting, etc.
                </p>
                <pre><code>from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
import time

app = FastAPI()

# CORS Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://example.com"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Custom logging middleware
@app.middleware("http")
async def add_process_time_header(request, call_next):
    start_time = time.time()
    response = await call_next(request)
    process_time = time.time() - start_time
    response.headers["X-Process-Time"] = str(process_time)
    return response</code></pre>

                <h3>2.3 Event Loop & Concurrency Model</h3>
                <div class="highlight info">
                    <strong>How Uvicorn's Event Loop Works:</strong>
                    <ul>
                        <li>Receives request A ‚Üí starts async function A</li>
                        <li>Function A hits await (I/O wait) ‚Üí event loop parks it</li>
                        <li>Receives request B ‚Üí starts async function B</li>
                        <li>Function B hits await ‚Üí event loop parks it</li>
                        <li>Meanwhile, function A's I/O completes ‚Üí event loop resumes A</li>
                        <li>Result: 100s-1000s of concurrent requests on a single thread!</li>
                    </ul>
                </div>

                <h3>2.4 Production Deployment: Gunicorn + Uvicorn Workers</h3>
                <p>
                    For production, you use Gunicorn (process manager) with multiple Uvicorn workers (one event loop per worker).
                </p>
                <pre><code># Install both
pip install gunicorn uvicorn

# Run with 4 workers
gunicorn main:app \
  -k uvicorn.workers.UvicornWorker \
  -b 0.0.0.0:8000 \
  -w 4

# Or using Python directly
python -m gunicorn main:app -k uvicorn.workers.UvicornWorker -w 4</code></pre>

                <div class="highlight success">
                    <strong>Benefits of Gunicorn + Uvicorn:</strong>
                    <ul>
                        <li>‚úÖ Utilize multiple CPU cores</li>
                        <li>‚úÖ Handle 10,000+ concurrent requests</li>
                        <li>‚úÖ Improved throughput and reliability</li>
                        <li>‚úÖ Automatic load balancing across workers</li>
                        <li>‚úÖ Worker restart on crashes (self-healing)</li>
                    </ul>
                </div>

                <h3>2.5 Lifespan Events & Health Checks</h3>
                <pre><code>from fastapi import FastAPI

app = FastAPI()

@app.on_event("startup")
async def startup():
    print("App is starting: connect to DB, init cache, etc.")
    # Initialize database connection
    # Setup cache
    # Load configuration

@app.on_event("shutdown")
async def shutdown():
    print("App is stopping: clean up resources.")
    # Close database connections
    # Flush caches
    # Save state

@app.get("/health")
async def health_check():
    return {"status": "ok", "version": "1.0.0"}</code></pre>

                <h3>2.6 WebSocket Support</h3>
                <pre><code>from fastapi import FastAPI, WebSocket

app = FastAPI()

@app.websocket("/ws/{client_id}")
async def websocket_endpoint(websocket: WebSocket, client_id: int):
    await websocket.accept()
    try:
        while True:
            data = await websocket.receive_text()
            await websocket.send_text(f"Echo: {data}")
    except Exception as e:
        print(f"WebSocket error: {e}")
    finally:
        await websocket.close()</code></pre>

                <div class="highlight">
                    <strong>Why Uvicorn + WebSocket matters:</strong>
                    <ul>
                        <li>Real-time chat applications</li>
                        <li>Live notifications</li>
                        <li>Real-time dashboards</li>
                        <li>Collaborative tools (Figma-like)</li>
                        <li>Gaming multiplayer servers</li>
                    </ul>
                </div>
            </section>

            <!-- MODULE 3: SWAGGER/OPENAPI -->
            <section id="module3">
                <h2>Module 3: Swagger & OpenAPI Mastery</h2>

                <h3>3.1 Swagger vs OpenAPI: Understanding the Ecosystem</h3>
                <div class="comparison-table">
                    <div class="comparison-col">
                        <h4>üìã OpenAPI</h4>
                        <p><strong>Specification</strong> - Standard format (JSON/YAML) that describes REST APIs</p>
                        <p style="font-size: 12px; margin-top: 10px;">Version: 3.0.x, 3.1.x</p>
                    </div>
                    <div class="comparison-col">
                        <h4>üé® Swagger UI</h4>
                        <p><strong>Interactive Documentation</strong> - Beautiful web UI to test APIs</p>
                        <p style="font-size: 12px; margin-top: 10px;">Available at: /docs</p>
                    </div>
                    <div class="comparison-col">
                        <h4>üî® Swagger Tools</h4>
                        <p><strong>Ecosystem</strong> - Editor, CodeGen, Inspector, etc.</p>
                        <p style="font-size: 12px; margin-top: 10px;">Auto-generate clients & servers</p>
                    </div>
                </div>

                <h3>3.2 Swagger Tools Ecosystem</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tool</th>
                            <th>Purpose</th>
                            <th>Use Case</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Swagger Editor</strong></td>
                            <td>Write/edit OpenAPI specs</td>
                            <td>Design APIs before coding (Spec-first)</td>
                        </tr>
                        <tr>
                            <td><strong>Swagger UI</strong></td>
                            <td>Interactive documentation</td>
                            <td>Test endpoints, explore API</td>
                        </tr>
                        <tr>
                            <td><strong>Swagger Codegen</strong></td>
                            <td>Generate client libraries</td>
                            <td>Auto-generate SDKs (JavaScript, Python, Java, etc.)</td>
                        </tr>
                        <tr>
                            <td><strong>Swagger Inspector</strong></td>
                            <td>Test and validate APIs</td>
                            <td>Create test collections, validate specs</td>
                        </tr>
                        <tr>
                            <td><strong>ReDoc</strong></td>
                            <td>Alternative documentation</td>
                            <td>Beautiful, mobile-friendly docs</td>
                        </tr>
                    </tbody>
                </table>

                <h3>3.3 OpenAPI Specification Structure</h3>
                <pre><code>openapi: 3.1.0
info:
  title: Pet Store API
  version: 1.0.0
  description: A sample Pet Store API
  contact:
    name: API Support
    email: support@petstore.com
  license:
    name: MIT

servers:
  - url: https://api.petstore.com
    description: Production server
  - url: https://staging.petstore.com
    description: Staging server

paths:
  /pets:
    get:
      summary: List all pets
      tags:
        - pets
      parameters:
        - name: limit
          in: query
          required: false
          schema:
            type: integer
      responses:
        '200':
          description: A list of pets
          content:
            application/json:
              schema:
                type: array
                items:
                  $ref: '#/components/schemas/Pet'
    post:
      summary: Create a pet
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/PetInput'
      responses:
        '201':
          description: Pet created

components:
  schemas:
    Pet:
      type: object
      properties:
        id:
          type: integer
        name:
          type: string
        status:
          type: string
          enum: [available, sold, pending]
      required: [id, name, status]</code></pre>

                <h3>3.4 FastAPI Automatic Documentation Generation</h3>
                <p>
                    FastAPI automatically generates OpenAPI specs from your Python code using type hints and docstrings.
                </p>
                <pre><code>from fastapi import FastAPI
from pydantic import BaseModel, Field
from typing import Optional

app = FastAPI(
    title="User Management API",
    description="Complete API for managing users",
    version="1.0.0",
    contact={
        "name": "API Support",
        "email": "support@example.com"
    }
)

class User(BaseModel):
    """User model for request/response"""
    id: int
    username: str = Field(..., min_length=3, max_length=50, description="Username")
    email: str = Field(..., regex=r"^\S+@\S+\.\S+$", description="Valid email")
    age: int = Field(..., ge=18, le=120, description="Must be 18+")
    is_active: bool = True
    profile_pic: Optional[str] = None

    class Config:
        json_schema_extra = {
            "example": {
                "id": 1,
                "username": "johndoe",
                "email": "john@example.com",
                "age": 30,
                "is_active": True,
                "profile_pic": "https://example.com/pic.jpg"
            }
        }

@app.get("/users/{user_id}", response_model=User, tags=["users"])
async def get_user(
    user_id: int = Field(..., gt=0, description="User ID"),
    skip: int = Field(0, ge=0, description="Skip N records")
):
    """
    Get a user by ID.
    
    - **user_id**: Unique user identifier
    - **skip**: Number of records to skip (pagination)
    
    Returns a complete User object.
    """
    return {
        "id": user_id,
        "username": "johndoe",
        "email": "john@example.com",
        "age": 30,
        "is_active": True
    }

@app.post("/users", response_model=User, status_code=201, tags=["users"])
async def create_user(user: User):
    """Create a new user"""
    return user

# Access at:
# GET /docs ‚Üí Swagger UI
# GET /redoc ‚Üí ReDoc
# GET /openapi.json ‚Üí OpenAPI spec (JSON)</code></pre>

                <h3>3.5 HTTP Methods & Status Codes</h3>
                <table>
                    <thead>
                        <tr>
                            <th>HTTP Method</th>
                            <th>Purpose</th>
                            <th>Typical Status Codes</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>GET</strong></td>
                            <td>Retrieve resources</td>
                            <td>200 OK, 404 Not Found, 401 Unauthorized</td>
                        </tr>
                        <tr>
                            <td><strong>POST</strong></td>
                            <td>Create resources</td>
                            <td>201 Created, 400 Bad Request, 409 Conflict</td>
                        </tr>
                        <tr>
                            <td><strong>PUT</strong></td>
                            <td>Full resource replacement</td>
                            <td>200 OK, 204 No Content, 404 Not Found</td>
                        </tr>
                        <tr>
                            <td><strong>PATCH</strong></td>
                            <td>Partial resource update</td>
                            <td>200 OK, 204 No Content, 400 Bad Request</td>
                        </tr>
                        <tr>
                            <td><strong>DELETE</strong></td>
                            <td>Remove resources</td>
                            <td>204 No Content, 404 Not Found, 401 Unauthorized</td>
                        </tr>
                    </tbody>
                </table>

                <h3>3.6 Code-First vs Spec-First API Design</h3>
                <div class="comparison-table">
                    <div class="comparison-col">
                        <h4>üíª Code-First (FastAPI Style)</h4>
                        <pre><code>Write Python Code
     ‚Üì
FastAPI Generates
OpenAPI Spec
     ‚Üì
Swagger UI +
Documentation</code></pre>
                        <p style="margin-top: 15px;"><strong>Pros:</strong> Fast, Pythonic, great for internal APIs</p>
                    </div>
                    <div class="comparison-col">
                        <h4>üìã Spec-First</h4>
                        <pre><code>Design OpenAPI
Spec (YAML)
     ‚Üì
Generate Server
Stubs
     ‚Üì
Implement
Logic</code></pre>
                        <p style="margin-top: 15px;"><strong>Pros:</strong> Better for multi-team, contracts, external partners</p>
                    </div>
                </div>

                <h3>3.7 Security & Authentication in Swagger</h3>
                <pre><code>from fastapi import FastAPI, Depends, HTTPException
from fastapi.security import HTTPBearer, HTTPAuthCredentials
from fastapi.openapi.utils import get_openapi

app = FastAPI()
security = HTTPBearer()

async def verify_token(credentials: HTTPAuthCredentials = Depends(security)):
    if credentials.credentials != "valid-token":
        raise HTTPException(status_code=403, detail="Invalid token")
    return credentials.credentials

@app.get("/secure", dependencies=[Depends(verify_token)])
async def secure_endpoint():
    """This endpoint requires Bearer token authentication"""
    return {"message": "You are authenticated!"}

# Customize OpenAPI schema to show security requirement
def custom_openapi():
    if app.openapi_schema:
        return app.openapi_schema
    
    openapi_schema = get_openapi(
        title="Secure API",
        version="1.0.0",
        routes=app.routes,
    )
    
    # Add Bearer scheme
    openapi_schema["components"]["securitySchemes"] = {
        "Bearer": {
            "type": "http",
            "scheme": "bearer",
            "bearerFormat": "JWT",
        }
    }
    
    # Apply to all endpoints
    openapi_schema["security"] = [{"Bearer": []}]
    app.openapi_schema = openapi_schema
    return app.openapi_schema

app.openapi = custom_openapi</code></pre>
            </section>

            <!-- INTEGRATION & ARCHITECTURE -->
            <section id="integration">
                <h2>Real-World Integration Patterns & Architecture</h2>

                <h3>4.1 Complete E-Commerce API Example</h3>
                <pre><code>from fastapi import FastAPI, HTTPException, Depends
from pydantic import BaseModel, Field
from typing import List
from enum import Enum

app = FastAPI(
    title="E-Commerce API",
    description="Full-featured product and order management",
    version="1.0.0"
)

class OrderStatus(str, Enum):
    pending = "pending"
    processing = "processing"
    shipped = "shipped"
    delivered = "delivered"

class Product(BaseModel):
    id: int
    name: str = Field(..., min_length=1, max_length=255)
    price: float = Field(..., gt=0)
    inventory: int = Field(..., ge=0)
    description: str = ""

class OrderItem(BaseModel):
    product_id: int
    quantity: int = Field(..., gt=0)

class Order(BaseModel):
    id: int
    user_id: int
    items: List[OrderItem]
    total: float
    status: OrderStatus = OrderStatus.pending

# In-memory database (replace with real DB in production)
products_db = []
orders_db = []

@app.get("/products", response_model=List[Product], tags=["Products"])
async def list_products(skip: int = 0, limit: int = 10):
    """List all available products with pagination"""
    return products_db[skip:skip + limit]

@app.post("/products", response_model=Product, status_code=201, tags=["Products"])
async def create_product(product: Product):
    """Create a new product (admin only)"""
    product.id = len(products_db) + 1
    products_db.append(product)
    return product

@app.post("/orders", response_model=Order, status_code=201, tags=["Orders"])
async def create_order(user_id: int, items: List[OrderItem]):
    """Create a new order"""
    order = Order(
        id=len(orders_db) + 1,
        user_id=user_id,
        items=items,
        total=sum(p.price * item.quantity for p in products_db for item in items if p.id == item.product_id),
        status=OrderStatus.pending
    )
    orders_db.append(order)
    return order

@app.get("/orders/{order_id}", response_model=Order, tags=["Orders"])
async def get_order(order_id: int):
    """Get order status and details"""
    for order in orders_db:
        if order.id == order_id:
            return order
    raise HTTPException(status_code=404, detail="Order not found")</code></pre>

                <h3>4.2 Project Structure Best Practices</h3>
                <pre><code>my-api/
‚îú‚îÄ‚îÄ app/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ main.py                 # Main FastAPI app
‚îÇ   ‚îú‚îÄ‚îÄ config.py               # Configuration management
‚îÇ   ‚îú‚îÄ‚îÄ models.py               # Database models (SQLAlchemy)
‚îÇ   ‚îú‚îÄ‚îÄ schemas.py              # Pydantic schemas
‚îÇ   ‚îú‚îÄ‚îÄ database.py             # Database connection
‚îÇ   ‚îú‚îÄ‚îÄ dependencies.py         # Dependency injection
‚îÇ   ‚îú‚îÄ‚îÄ routers/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ users.py            # User routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ products.py         # Product routes
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ orders.py           # Order routes
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.py             # Authentication routes
‚îÇ   ‚îú‚îÄ‚îÄ middleware/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ logging.py          # Request logging
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ auth.py             # Auth middleware
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ __init__.py
‚îÇ       ‚îú‚îÄ‚îÄ security.py         # JWT, password hashing
‚îÇ       ‚îî‚îÄ‚îÄ validators.py       # Custom validators
‚îú‚îÄ‚îÄ tests/
‚îÇ   ‚îú‚îÄ‚îÄ __init__.py
‚îÇ   ‚îú‚îÄ‚îÄ test_users.py
‚îÇ   ‚îú‚îÄ‚îÄ test_products.py
‚îÇ   ‚îî‚îÄ‚îÄ test_orders.py
‚îú‚îÄ‚îÄ requirements.txt
‚îú‚îÄ‚îÄ .env
‚îú‚îÄ‚îÄ .env.example
‚îú‚îÄ‚îÄ .gitignore
‚îú‚îÄ‚îÄ docker-compose.yml
‚îú‚îÄ‚îÄ Dockerfile
‚îî‚îÄ‚îÄ main.py                     # Entry point</code></pre>

                <h3>4.3 Database Integration with SQLAlchemy</h3>
                <pre><code>from sqlalchemy import create_engine, Column, Integer, String
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, Session
from pydantic import BaseModel

DATABASE_URL = "postgresql://user:password@localhost/dbname"
engine = create_engine(DATABASE_URL)
SessionLocal = sessionmaker(bind=engine)
Base = declarative_base()

# SQLAlchemy Model
class UserDB(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    username = Column(String, unique=True, index=True)
    email = Column(String, unique=True, index=True)
    hashed_password = Column(String)

# Pydantic Schema
class UserCreate(BaseModel):
    username: str
    email: str
    password: str

class UserResponse(BaseModel):
    id: int
    username: str
    email: str
    
    class Config:
        from_attributes = True

Base.metadata.create_all(bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

@app.post("/users", response_model=UserResponse)
async def create_user(user: UserCreate, db: Session = Depends(get_db)):
    db_user = UserDB(
        username=user.username,
        email=user.email,
        hashed_password=hash(user.password)
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user</code></pre>

                <h3>4.4 Error Handling & Validation</h3>
                <pre><code>from fastapi import HTTPException, status
from pydantic import ValidationError

class APIException(Exception):
    def __init__(self, status_code: int, detail: str):
        self.status_code = status_code
        self.detail = detail

@app.exception_handler(APIException)
async def api_exception_handler(request, exc):
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail, "error_code": exc.status_code},
    )

@app.get("/items/{item_id}")
async def get_item(item_id: int = Field(..., gt=0)):
    if item_id <= 0:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Item ID must be positive"
        )
    if item_id > 1000:
        raise APIException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Item not found"
        )
    return {"item_id": item_id}</code></pre>

                <h3>4.5 API Gateway Pattern</h3>
                <pre><code>from fastapi import FastAPI
from httpx import AsyncClient

app = FastAPI(title="API Gateway")

SERVICE_URLS = {
    "users": "http://users-service:8001",
    "products": "http://products-service:8002",
    "orders": "http://orders-service:8003",
}

@app.get("/api/v1/users/{user_id}")
async def get_user(user_id: int):
    """Forward request to user microservice"""
    async with AsyncClient() as client:
        response = await client.get(f"{SERVICE_URLS['users']}/users/{user_id}")
        return response.json()

@app.post("/api/v1/orders")
async def create_order(order: dict):
    """Create order via microservice"""
    async with AsyncClient() as client:
        response = await client.post(
            f"{SERVICE_URLS['orders']}/orders",
            json=order
        )
        return response.json()</code></pre>
            </section>

            <!-- PERFORMANCE & OPTIMIZATION -->
            <section id="performance">
                <h2>Performance Optimization & Best Practices</h2>

                <h3>5.1 Performance Tuning Checklist</h3>
                <div class="highlight success">
                    <strong>‚úÖ Optimization Strategies:</strong>
                    <ul>
                        <li><strong>Use async I/O</strong> - Always use <code>async def</code> for database/API calls</li>
                        <li><strong>Offload heavy work</strong> - Use background jobs (Celery, RQ) for CPU-bound tasks</li>
                        <li><strong>Database connection pooling</strong> - Reuse connections instead of creating new ones</li>
                        <li><strong>Use async DB drivers</strong> - asyncpg, motor, databases library</li>
                        <li><strong>Caching</strong> - Redis for session, query results, API responses</li>
                        <li><strong>Multiple workers</strong> - Gunicorn with 4-8 workers (2x CPU cores)</li>
                        <li><strong>Compression</strong> - gzip compression for responses > 1KB</li>
                        <li><strong>Monitoring</strong> - Track metrics: response time, error rate, CPU, memory</li>
                    </ul>
                </div>

                <h3>5.2 Caching Strategies</h3>
                <pre><code>from fastapi import FastAPI
from fastapi_cache2 import FastAPICache2
from fastapi_cache2.backends.redis import RedisBackend
from redis import asyncio as aioredis

app = FastAPI()

@app.on_event("startup")
async def startup():
    redis = aioredis.from_url("redis://localhost")
    FastAPICache2.init(RedisBackend(redis), prefix="fastapi-cache")

from fastapi_cache2.decorators import cache

@app.get("/items")
@cache(expire=300)  # Cache for 5 minutes
async def get_items():
    # Expensive query
    return await db.query(Item).all()</code></pre>

                <h3>5.3 Load Testing</h3>
                <pre><code># Using Apache Bench
ab -n 10000 -c 100 http://localhost:8000/

# Using wrk (better for concurrent connections)
wrk -t12 -c400 -d30s http://localhost:8000/

# Using hey
hey -n 10000 -c 100 http://localhost:8000/

# Using locust (Python-based, great for complex scenarios)
pip install locust

# locustfile.py
from locust import HttpUser, task

class APIUser(HttpUser):
    @task
    def get_items(self):
        self.client.get("/items")
    
    @task(2)
    def create_item(self):
        self.client.post("/items", json={"name": "test"})</code></pre>

                <h3>5.4 Production Deployment Checklist</h3>
                <div class="highlight warning">
                    <strong>üîí Security & Production Readiness:</strong>
                    <ul>
                        <li>‚úÖ Use HTTPS/SSL certificates</li>
                        <li>‚úÖ Input validation and sanitization</li>
                        <li>‚úÖ CORS properly configured</li>
                        <li>‚úÖ Environment variables for secrets (not hardcoded)</li>
                        <li>‚úÖ Rate limiting enabled</li>
                        <li>‚úÖ Logging and monitoring enabled</li>
                        <li>‚úÖ Error tracking (Sentry, etc.)</li>
                        <li>‚úÖ Database backups and replication</li>
                        <li>‚úÖ Load balancer configured</li>
                        <li>‚úÖ Health checks implemented</li>
                    </ul>
                </div>

                <h3>5.5 Docker Deployment</h3>
                <pre><code># Dockerfile
FROM python:3.11-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install -r requirements.txt

COPY app ./app

# Use Gunicorn with Uvicorn workers for production
CMD ["gunicorn", "app.main:app", \
     "--workers", "4", \
     "--worker-class", "uvicorn.workers.UvicornWorker", \
     "--bind", "0.0.0.0:8000", \
     "--access-logfile", "-", \
     "--error-logfile", "-"]

# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "8000:8000"
    environment:
      - DATABASE_URL=postgresql://user:pass@db:5432/api
      - REDIS_URL=redis://redis:6379
    depends_on:
      - db
      - redis
  
  db:
    image: postgres:15
    environment:
      POSTGRES_PASSWORD: password
    volumes:
      - postgres_data:/var/lib/postgresql/data
  
  redis:
    image: redis:7

volumes:
  postgres_data:</code></pre>
            </section>

            <!-- USPs & FEATURES -->
            <section id="usps">
                <h2>‚≠ê Unique Selling Points & Competitive Advantages</h2>

                <h3>5.1 Why Choose Uvicorn?</h3>
                <div class="usp-grid">
                    <div class="usp-item">
                        <div class="usp-icon">‚ö°</div>
                        <h4>Lightning Performance</h4>
                        <p>Async-first design enables handling 1000s of concurrent connections efficiently on minimal resources.</p>
                    </div>
                    <div class="usp-item">
                        <div class="usp-icon">üîÑ</div>
                        <h4>Modern Async/Await</h4>
                        <p>Native Python 3.7+ async support with intuitive async/await syntax vs callback hell.</p>
                    </div>
                    <div class="usp-item">
                        <div class="usp-icon">üîå</div>
                        <h4>WebSocket Support</h4>
                        <p>Built-in WebSocket support for real-time applications (chat, notifications, dashboards).</p>
                    </div>
                    <div class="usp-item">
                        <div class="usp-icon">üìö</div>
                        <h4>Auto Documentation</h4>
                        <p>FastAPI + Uvicorn auto-generates interactive Swagger UI and ReDoc from Python type hints.</p>
                    </div>
                    <div class="usp-item">
                        <div class="usp-icon">üõ°Ô∏è</div>
                        <h4>Security First</h4>
                        <p>Built-in OAuth2, JWT, and other security schemes. Easy authentication and authorization.</p>
                    </div>
                    <div class="usp-item">
                        <div class="usp-icon">üöÄ</div>
                        <h4>Developer Experience</h4>
                        <p>Minimal boilerplate, intuitive API, excellent error messages, hot-reload for development.</p>
                    </div>
                    <div class="usp-item">
                        <div class="usp-icon">üê≥</div>
                        <h4>Container Ready</h4>
                        <p>Perfect for Docker/Kubernetes deployments. Minimal dependencies, small image size.</p>
                    </div>
                    <div class="usp-item">
                        <div class="usp-icon">üìä</div>
                        <h4>Scalability</h4>
                        <p>Works seamlessly with Gunicorn for multiple worker processes and horizontal scaling.</p>
                    </div>
                </div>

                <h3>5.2 Why Choose Swagger/OpenAPI?</h3>
                <div class="card-grid">
                    <div class="card">
                        <h3>üéØ Industry Standard</h3>
                        <p>OpenAPI 3.0+ is the de facto standard adopted by major tech companies (Google, AWS, Microsoft).</p>
                    </div>
                    <div class="card">
                        <h3>üîó SDK Generation</h3>
                        <p>Auto-generate client libraries in 30+ languages (JavaScript, Python, Go, Java, etc.).</p>
                    </div>
                    <div class="card">
                        <h3>ü§ù Team Collaboration</h3>
                        <p>Use specs as contracts between frontend and backend teams, enabling parallel development.</p>
                    </div>
                    <div class="card">
                        <h3>üìù Living Documentation</h3>
                        <p>Always up-to-date documentation that stays in sync with code (no manual doc updates).</p>
                    </div>
                    <div class="card">
                        <h3>üß™ API Testing</h3>
                        <p>Swagger UI lets developers test endpoints directly without external tools like Postman.</p>
                    </div>
                    <div class="card">
                        <h3>üîç API Discovery</h3>
                        <p>Automated API discovery for internal tools, mobile apps, and third-party integrations.</p>
                    </div>
                </div>

                <h3>5.3 Pros & Cons Analysis</h3>
                <div class="pros-cons-grid">
                    <div class="pros">
                        <h4>‚úÖ Pros of Uvicorn</h4>
                        <ul>
                            <li>Exceptional performance (1000s concurrent connections)</li>
                            <li>Native async/await support</li>
                            <li>WebSocket out-of-the-box</li>
                            <li>Small memory footprint</li>
                            <li>Easy to learn and use</li>
                            <li>Great ecosystem (FastAPI, Starlette)</li>
                            <li>Excellent for microservices</li>
                            <li>Hot-reload in development</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons of Uvicorn</h4>
                        <ul>
                            <li>Relatively young project (since 2016)</li>
                            <li>Smaller community than Django/Flask</li>
                            <li>Less third-party integrations</li>
                            <li>Not suitable for CPU-bound tasks</li>
                            <li>Requires async mindset (learning curve)</li>
                            <li>Some libraries still sync-only</li>
                            <li>Debugging async code can be tricky</li>
                        </ul>
                    </div>
                </div>

                <div class="pros-cons-grid">
                    <div class="pros">
                        <h4>‚úÖ Pros of Swagger/OpenAPI</h4>
                        <ul>
                            <li>Industry standard, universally recognized</li>
                            <li>Automatic documentation generation</li>
                            <li>Client SDK generation in 30+ languages</li>
                            <li>Great for API discovery</li>
                            <li>Enables spec-first development</li>
                            <li>Interactive testing UI (Swagger UI)</li>
                            <li>Better API governance</li>
                            <li>Works with any language/framework</li>
                        </ul>
                    </div>
                    <div class="cons">
                        <h4>‚ùå Cons of Swagger/OpenAPI</h4>
                        <ul>
                            <li>Specs can become verbose (large APIs)</li>
                            <li>Learning curve for OpenAPI YAML/JSON</li>
                            <li>Keeping spec in sync requires discipline</li>
                            <li>Code generation quality varies</li>
                            <li>Not great for real-time/streaming APIs</li>
                            <li>Limited GraphQL support</li>
                            <li>Tooling ecosystem fragmented</li>
                        </ul>
                    </div>
                </div>
            </section>

            <!-- ALTERNATIVES -->
            <section id="alternatives">
                <h2>üîÑ Alternatives & Competitive Landscape</h2>

                <h3>6.1 ASGI Server Alternatives</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Server</th>
                            <th>Language</th>
                            <th>Performance</th>
                            <th>Maturity</th>
                            <th>Best For</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Uvicorn</strong></td>
                            <td>Python (C extensions)</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>Mature</td>
                            <td>Python async APIs, real-time</td>
                        </tr>
                        <tr>
                            <td><strong>Hypercorn</strong></td>
                            <td>Python</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>Mature</td>
                            <td>HTTP/2, HTTP/3 support</td>
                        </tr>
                        <tr>
                            <td><strong>Daphne</strong></td>
                            <td>Python</td>
                            <td>‚≠ê‚≠ê‚≠ê</td>
                            <td>Mature</td>
                            <td>Django Channels projects</td>
                        </tr>
                        <tr>
                            <td><strong>Go (net/http)</strong></td>
                            <td>Go</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>Very Mature</td>
                            <td>Best performance overall</td>
                        </tr>
                        <tr>
                            <td><strong>Node.js (Express)</strong></td>
                            <td>JavaScript</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>Mature</td>
                            <td>Full-stack JS teams</td>
                        </tr>
                        <tr>
                            <td><strong>Rust (Actix/Rocket)</strong></td>
                            <td>Rust</td>
                            <td>‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê</td>
                            <td>Mature</td>
                            <td>Maximum performance + safety</td>
                        </tr>
                    </tbody>
                </table>

                <h3>6.2 Python Framework Alternatives</h3>
                <div class="card-grid">
                    <div class="card">
                        <h3>üîß Django</h3>
                        <p><strong>Pros:</strong> Batteries-included, ORM, admin panel, huge community</p>
                        <p><strong>Cons:</strong> Heavy, monolithic, slower than async</p>
                        <p><strong>Use when:</strong> Large traditional web apps, admin backend needed</p>
                    </div>
                    <div class="card">
                        <h3>üéØ Flask</h3>
                        <p><strong>Pros:</strong> Lightweight, flexible, minimal dependencies</p>
                        <p><strong>Cons:</strong> Synchronous, fewer batteries, needs more boilerplate</p>
                        <p><strong>Use when:</strong> Simple APIs, microservices, learning</p>
                    </div>
                    <div class="card">
                        <h3>‚ö° FastAPI</h3>
                        <p><strong>Pros:</strong> Async, auto-docs, validation, modern</p>
                        <p><strong>Cons:</strong> Younger ecosystem, async learning curve</p>
                        <p><strong>Use when:</strong> Modern APIs, real-time, high performance needed</p>
                    </div>
                    <div class="card">
                        <h3>üåê Tornado</h3>
                        <p><strong>Pros:</strong> Async, WebSocket, real-time capable</p>
                        <p><strong>Cons:</strong> Smaller community, older async model</p>
                        <p><strong>Use when:</strong> Real-time apps before async became standard</p>
                    </div>
                    <div class="card">
                        <h3>üé® Starlette</h3>
                        <p><strong>Pros:</strong> Lightweight ASGI framework, middleware</p>
                        <p><strong>Cons:</strong> Less batteries than FastAPI, no auto-docs</p>
                        <p><strong>Use when:</strong> Building custom frameworks, minimal setup</p>
                    </div>
                    <div class="card">
                        <h3>üîÄ Quart</h3>
                        <p><strong>Pros:</strong> Flask-like async API</p>
                        <p><strong>Cons:</strong> Less mature, smaller community</p>
                        <p><strong>Use when:</strong> Flask developers wanting async</p>
                    </div>
                </div>

                <h3>6.3 API Documentation Alternatives</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Tool</th>
                            <th>Approach</th>
                            <th>Pros</th>
                            <th>Cons</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Swagger/OpenAPI</strong></td>
                            <td>Standardized spec</td>
                            <td>Industry standard, auto-SDK generation</td>
                            <td>Verbose specs, learning curve</td>
                        </tr>
                        <tr>
                            <td><strong>GraphQL</strong></td>
                            <td>Query language</td>
                            <td>Powerful, flexible, excellent docs</td>
                            <td>Overkill for simple APIs, N+1 queries</td>
                        </tr>
                        <tr>
                            <td><strong>AsyncAPI</strong></td>
                            <td>Event-driven spec</td>
                            <td>Great for async/events, WebSockets</td>
                            <td>Newer, smaller community</td>
                        </tr>
                        <tr>
                            <td><strong>RAML</strong></td>
                            <td>REST spec language</td>
                            <td>More concise than OpenAPI</td>
                            <td>Less popular, less tooling</td>
                        </tr>
                        <tr>
                            <td><strong>Postman Collections</strong></td>
                            <td>Runtime-based</td>
                            <td>Easy to create and share</td>
                            <td>Not standardized, manual maintenance</td>
                        </tr>
                    </tbody>
                </table>

                <h3>6.4 When to Use Each Solution</h3>
                <div class="highlight info">
                    <strong>Decision Matrix:</strong>
                    <ul>
                        <li><strong>Use Uvicorn + FastAPI if:</strong> Building modern APIs, need high concurrency, async operations important</li>
                        <li><strong>Use Django if:</strong> Large monolithic app, admin panel needed, team familiar with Django</li>
                        <li><strong>Use Go if:</strong> Maximum performance non-negotiable, microservices architecture</li>
                        <li><strong>Use Node.js if:</strong> Full-stack JavaScript team, frontend-heavy app</li>
                        <li><strong>Use Swagger/OpenAPI if:</strong> Multi-team development, third-party integrations, long-term API</li>
                        <li><strong>Use GraphQL if:</strong> Complex queries, client-driven fetching, rapidly evolving API</li>
                    </ul>
                </div>
            </section>

            <!-- FUTURE & EMERGING TRENDS -->
            <section id="future">
                <h2>üöÄ Future Roadmap & Emerging Trends</h2>

                <h3>7.1 Uvicorn Evolution & Roadmap</h3>
                <div class="highlight success">
                    <strong>üîÆ Expected Evolution:</strong>
                    <ul>
                        <li><strong>HTTP/2 & HTTP/3 native support</strong> - Hypercorn leading, Uvicorn may follow</li>
                        <li><strong>Performance improvements</strong> - Continued optimization with Rust extensions</li>
                        <li><strong>Better debugging tools</strong> - Async debugging is getting better</li>
                        <li><strong>ASGI 3.0+</strong> - Enhanced spec with more features</li>
                        <li><strong>Better observability</strong> - OpenTelemetry integration, distributed tracing</li>
                        <li><strong>AI-powered optimization</strong> - Auto-tuning worker counts, resource allocation</li>
                    </ul>
                </div>

                <h3>7.2 Python Web Development Trends</h3>
                <div class="card-grid">
                    <div class="card">
                        <h3>üìà Async Everything</h3>
                        <p>Async is becoming the default for new Python projects. Libraries moving to async-first design.</p>
                    </div>
                    <div class="card">
                        <h3>üîó Edge Computing</h3>
                        <p>Cloudflare Workers, AWS Lambda using FastAPI/Uvicorn patterns for serverless.</p>
                    </div>
                    <div class="card">
                        <h3>ü§ñ AI/ML Integration</h3>
                        <p>APIs for LLMs, embeddings, ML models becoming standard (LangChain, Hugging Face).</p>
                    </div>
                    <div class="card">
                        <h3>üîê Security First</h3>
                        <p>Authentication, authorization, encryption becoming built-in, not afterthought.</p>
                    </div>
                    <div class="card">
                        <h3>üìä Observability</h3>
                        <p>OpenTelemetry, distributed tracing, metrics becoming standard across frameworks.</p>
                    </div>
                    <div class="card">
                        <h3>üåç Multi-region</h3>
                        <p>APIs becoming globally distributed with edge caching, replication across regions.</p>
                    </div>
                </div>

                <h3>7.3 OpenAPI Evolution</h3>
                <div class="highlight warning">
                    <strong>üìã Future of OpenAPI/Swagger:</strong>
                    <ul>
                        <li><strong>OpenAPI 4.0</strong> - Expected improvements for better schema expressiveness</li>
                        <li><strong>Better async/event support</strong> - Addressing WebSocket, Server-Sent Events limitations</li>
                        <li><strong>GraphQL integration</strong> - Hybrid specs supporting both REST and GraphQL</li>
                        <li><strong>Machine-readable governance</strong> - API policies, compliance rules in spec</li>
                        <li><strong>AI-powered documentation</strong> - Auto-generated examples, usage patterns</li>
                        <li><strong>Multi-protocol support</strong> - gRPC, AMQP specs alongside REST</li>
                    </ul>
                </div>

                <h3>7.4 Industry Adoption & Market Trends</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Trend</th>
                            <th>Impact</th>
                            <th>Timeline</th>
                        </tr>
                    </thead>
                    <tbody>
                        <tr>
                            <td><strong>Async adoption</strong></td>
                            <td>More Python projects going async-first</td>
                            <td>2024-2025</td>
                        </tr>
                        <tr>
                            <td><strong>Microservices growth</strong></td>
                            <td>Uvicorn/FastAPI ideal for microservices</td>
                            <td>Ongoing</td>
                        </tr>
                        <tr>
                            <td><strong>API-first development</strong></td>
                            <td>More companies starting with API specs</td>
                            <td>Ongoing</td>
                        </tr>
                        <tr>
                            <td><strong>Real-time requirements</strong></td>
                            <td>More WebSocket use cases (chat, notifications)</td>
                            <td>Ongoing</td>
                        </tr>
                        <tr>
                            <td><strong>Serverless adoption</strong></td>
                            <td>ASGI frameworks moving to edge/serverless</td>
                            <td>2024-2025</td>
                        </tr>
                        <tr>
                            <td><strong>AI API explosion</strong></td>
                            <td>High demand for async API frameworks</td>
                            <td>2024 onward</td>
                        </tr>
                    </tbody>
                </table>

                <h3>7.5 Skills to Develop for 2024+</h3>
                <div class="usp-grid">
                    <div class="usp-item">
                        <div class="usp-icon">üîÑ</div>
                        <h4>Async Programming</h4>
                        <p>Master async/await patterns, event loops, and concurrent programming paradigms.</p>
                    </div>
                    <div class="usp-item">
                        <div class="usp-icon">üê≥</div>
                        <h4>Container Orchestration</h4>
                        <p>Kubernetes, Docker Compose for deploying and scaling ASGI applications.</p>
                    </div>
                    <div class="usp-item">
                        <div class="usp-icon">üì°</div>
                        <h4>API Design</h4>
                        <p>RESTful design, OpenAPI spec creation, API versioning strategies.</p>
                    </div>
                    <div class="usp-item">
                        <div class="usp-icon">üîê</div>
                        <h4>Security & Auth</h4>
                        <p>OAuth2, JWT, rate limiting, API key management, CORS handling.</p>
                    </div>
                    <div class="usp-item">
                        <div class="usp-icon">üìä</div>
                        <h4>Observability</h4>
                        <p>OpenTelemetry, metrics collection, distributed tracing, log aggregation.</p>
                    </div>
                    <div class="usp-item">
                        <div class="usp-icon">ü§ñ</div>
                        <h4>AI/ML APIs</h4>
                        <p>Building APIs around ML models, LLM integration, prompt engineering.</p>
                    </div>
                </div>
            </section>

            <!-- CONCLUSION -->
            <section>
                <h2>Summary & Next Steps</h2>
                <div class="highlight success">
                    <strong>üéì Key Takeaways:</strong>
                    <ul>
                        <li>‚úÖ Uvicorn is the modern, high-performance ASGI server for Python async applications</li>
                        <li>‚úÖ It enables building APIs that handle 1000s of concurrent connections efficiently</li>
                        <li>‚úÖ FastAPI + Uvicorn auto-generate beautiful Swagger/OpenAPI documentation</li>
                        <li>‚úÖ Async/await is the future of Python backend development</li>
                        <li>‚úÖ OpenAPI/Swagger is the industry standard for API specifications</li>
                        <li>‚úÖ Together they form a powerful foundation for modern API development</li>
                    </ul>
                </div>

                <h3>üìö Learning Path</h3>
                <ol style="font-size: 16px; line-height: 2;">
                    <li><strong>Week 1:</strong> Learn Python async/await basics and event loops</li>
                    <li><strong>Week 2:</strong> Build your first FastAPI app with Uvicorn</li>
                    <li><strong>Week 3:</strong> Explore Swagger UI and OpenAPI documentation</li>
                    <li><strong>Week 4:</strong> Add database integration, authentication, error handling</li>
                    <li><strong>Week 5:</strong> Deploy with Docker and Gunicorn</li>
                    <li><strong>Week 6:</strong> Performance tuning and monitoring</li>
                    <li><strong>Week 7+:</strong> Build real-world projects, contribute to open source</li>
                </ol>

                <h3>üöÄ Recommended Resources</h3>
                <ul>
                    <li>üìñ <strong>Official Docs:</strong> FastAPI documentation (fastapi.tiangolo.com)</li>
                    <li>üìñ <strong>Official Docs:</strong> Uvicorn documentation (www.uvicorn.org)</li>
                    <li>üéì <strong>Course:</strong> "Build Web APIs with FastAPI" on Real Python</li>
                    <li>üí¨ <strong>Community:</strong> FastAPI Discord, Stack Overflow tags</li>
                    <li>üìö <strong>Books:</strong> "Web Development with FastAPI" by Sebasti√°n Ram√≠rez</li>
                    <li>üîó <strong>GitHub:</strong> explore FastAPI/Uvicorn projects</li>
                </ul>
            </section>

        </div>
    </div>

    <!-- Footer -->
    <footer>
        <div class="container">
            <p>&copy; 2024 Complete Uvicorn & Swagger Study Guide | All Rights Reserved</p>
            <p>Last Updated: December 2024 | Version 2.0</p>
            <p style="font-size: 12px; margin-top: 15px;">This comprehensive guide combines best practices from production deployments, open-source communities, and industry standards.</p>
        </div>
    </footer>

    <!-- Scroll to top button -->
    <div class="scrollspy" onclick="window.scrollTo({top: 0, behavior: 'smooth'})">‚Üë</div>

    <script>
        // Smooth scroll for navigation links
        document.querySelectorAll('nav a').forEach(link => {
            link.addEventListener('click', function(e) {
                const href = this.getAttribute('href');
                if (href.startsWith('#')) {
                    e.preventDefault();
                    const element = document.querySelector(href);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth' });
                    }
                }
            });
        });

        // TOC item click handlers
        document.querySelectorAll('.toc-item a').forEach(link => {
            link.addEventListener('click', function(e) {
                const href = this.getAttribute('href');
                if (href.startsWith('#')) {
                    e.preventDefault();
                    const element = document.querySelector(href);
                    if (element) {
                        element.scrollIntoView({ behavior: 'smooth' });
                    }
                }
            });
        });

        // Show/hide scroll-to-top button
        window.addEventListener('scroll', function() {
            const scrollspy = document.querySelector('.scrollspy');
            if (window.scrollY > 300) {
                scrollspy.style.display = 'flex';
            } else {
                scrollspy.style.display = 'none';
            }
        });

        // Code syntax highlighting (basic)
        document.querySelectorAll('pre code').forEach(block => {
            // Basic syntax highlighting simulation
            block.innerHTML = block.innerHTML
                .replace(/\b(async|await|def|class|return|import|from|if|else|for|while|try|except|finally)\b/g, '<span style="color: #569cd6;">$1</span>')
                .replace(/(".*?"|\'.*?\')/g, '<span style="color: #ce9178;">$1</span>')
                .replace(/(\#.*?)(?=<|$)/g, '<span style="color: #6a9955;">$1</span>');
        });

        // Initialize animations on scroll
        const observerOptions = {
            threshold: 0.1,
            rootMargin: '0px 0px -100px 0px'
        };

        const observer = new IntersectionObserver(function(entries) {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.style.opacity = '1';
                    entry.target.style.transform = 'translateY(0)';
                }
            });
        }, observerOptions);

        document.querySelectorAll('.card, .usp-item, .highlight, table').forEach(el => {
            el.style.opacity = '0';
            el.style.transform = 'translateY(20px)';
            el.style.transition = 'opacity 0.5s ease, transform 0.5s ease';
            observer.observe(el);
        });

        // Print friendly
        window.addEventListener('beforeprint', function() {
            document.body.style.backgroundColor = 'white';
        });
    </script>
</body>
</html>

[Complete HTML code as shown above - 110+ KB comprehensive study guide with all sections, responsive design, interactive elements, and rich content]
