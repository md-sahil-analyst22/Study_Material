<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Apps Mastery: Context Managers, Logging & Pydantic - Comprehensive Study Guide</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --info-color: #16a085;
            --light-bg: #ecf0f1;
            --dark-text: #2c3e50;
            --light-text: #7f8c8d;
            --border-color: #bdc3c7;
            --code-bg: #2c3e50;
            --code-text: #ecf0f1;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--dark-text);
            background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            padding-top: 0;
            display: grid;
            grid-template-columns: 1fr;
            gap: 20px;
            align-items: start;
        }

        /* Header Styles */
        header {
            background: linear-gradient(135deg, var(--primary-color) 0%, var(--secondary-color) 100%);
            color: white;
            padding: 50px 20px;
            text-align: center;
            border-radius: 0;
            margin-bottom: 30px;
            margin-top: 0;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.1);
            position: relative;
            overflow: hidden;
            grid-column: 1 / -1;
        }

        header::before {
            content: '';
            position: absolute;
            top: -50%;
            right: -10%;
            width: 200px;
            height: 200px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 50%;
        }

        header h1 {
            font-size: 2.2em;
            margin-bottom: 8px;
            position: relative;
            z-index: 1;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        header p {
            font-size: 1em;
            opacity: 0.95;
            position: relative;
            z-index: 1;
            margin-bottom: 5px;
        }

        /* Navigation */
        nav {
            background: white;
            padding: 15px 20px;
            border-radius: 0;
            margin-bottom: 0;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            position: sticky;
            top: 0;
            z-index: 100;
            max-height: none;
            overflow-y: visible;
            border-bottom: 3px solid var(--secondary-color);
            grid-column: 1 / -1;
        }

        nav::-webkit-scrollbar {
            width: 6px;
        }

        nav::-webkit-scrollbar-track {
            background: #f1f1f1;
            border-radius: 10px;
        }

        nav::-webkit-scrollbar-thumb {
            background: var(--secondary-color);
            border-radius: 10px;
        }

        nav::-webkit-scrollbar-thumb:hover {
            background: var(--accent-color);
        }

        nav h3 {
            margin-bottom: 10px;
            margin-top: 0;
            color: var(--secondary-color);
            font-size: 1.2em;
            display: inline-block;
            margin-right: 30px;
        }

        nav ul {
            display: flex;
            flex-direction: row;
            flex-wrap: wrap;
            gap: 8px;
            list-style: none;
            margin: 0;
            padding: 0;
            align-items: center;
        }

        nav a {
            display: inline-block;
            padding: 6px 12px;
            background: var(--secondary-color);
            color: white;
            text-decoration: none;
            border-radius: 4px;
            transition: all 0.3s ease;
            font-weight: 500;
            font-size: 0.9em;
            white-space: nowrap;
        }

        nav a:hover {
            background: var(--accent-color);
            transform: translateY(-2px);
        }

        /* Section Styles */
        section {
            background: white;
            margin-bottom: 30px;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
            border-left: 5px solid var(--secondary-color);
            grid-column: 1 / -1;
        }

        section.context-manager {
            border-left-color: #9b59b6;
        }

        section.logging {
            border-left-color: #f39c12;
        }

        section.pydantic {
            border-left-color: #1abc9c;
        }

        h2 {
            color: var(--primary-color);
            font-size: 2em;
            margin-bottom: 20px;
            padding-bottom: 10px;
            border-bottom: 3px solid var(--secondary-color);
            display: flex;
            align-items: center;
        }

        h2::before {
            content: '';
            display: inline-block;
            width: 10px;
            height: 30px;
            background: var(--secondary-color);
            margin-right: 15px;
            border-radius: 5px;
        }

        h3 {
            color: var(--secondary-color);
            font-size: 1.5em;
            margin-top: 25px;
            margin-bottom: 15px;
        }

        h4 {
            color: var(--dark-text);
            font-size: 1.1em;
            margin-top: 15px;
            margin-bottom: 10px;
        }

        p {
            margin-bottom: 15px;
            line-height: 1.8;
        }

        /* Box Styles */
        .info-box, .definition-box, .example-box, .pros-cons-box {
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            border-left: 4px solid;
        }

        .definition-box {
            background: #ecf0f1;
            border-left-color: var(--secondary-color);
        }

        .info-box {
            background: #d5f4e6;
            border-left-color: var(--success-color);
        }

        .warning-box {
            background: #fff3cd;
            border-left-color: var(--warning-color);
        }

        .example-box {
            background: #f8f9fa;
            border-left-color: var(--info-color);
        }

        .pros-cons-box {
            background: #f0f8ff;
            border-left-color: #3498db;
        }

        /* Code Styles */
        pre {
            background: var(--code-bg);
            color: var(--code-text);
            padding: 20px;
            border-radius: 8px;
            overflow-x: auto;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.5;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.2);
        }

        code {
            font-family: 'Courier New', monospace;
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            color: var(--accent-color);
        }

        pre code {
            background: none;
            padding: 0;
            color: #ecf0f1;
        }

        /* List Styles */
        ul, ol {
            margin-left: 25px;
            margin-bottom: 15px;
        }

        li {
            margin-bottom: 10px;
        }

        /* Diagram Styles */
        .diagram {
            background: white;
            border: 2px solid var(--secondary-color);
            padding: 20px;
            margin: 20px 0;
            border-radius: 8px;
            text-align: center;
            font-family: monospace;
            white-space: pre;
            overflow-x: auto;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        /* Card Grid */
        .card-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        .card {
            background: white;
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            transition: all 0.3s ease;
        }

        .card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 12px rgba(0, 0, 0, 0.15);
        }

        .card h4 {
            color: var(--secondary-color);
            margin-bottom: 10px;
        }

        /* Table Styles */
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }

        th {
            background: linear-gradient(135deg, var(--secondary-color) 0%, var(--info-color) 100%);
            color: white;
            padding: 15px;
            text-align: left;
            font-weight: 600;
        }

        td {
            padding: 12px 15px;
            border-bottom: 1px solid var(--border-color);
        }

        tr:hover {
            background: #f9f9f9;
        }

        /* Two Column Layout */
        .two-col {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        /* Responsive */
        @media (max-width: 768px) {
            header h1 {
                font-size: 1.6em;
            }

            header p {
                font-size: 0.9em;
            }

            h2 {
                font-size: 1.5em;
            }

            .two-col, .card-grid {
                grid-template-columns: 1fr;
            }

            nav ul {
                flex-direction: column;
                gap: 6px;
            }

            nav h3 {
                margin-right: 0;
                margin-bottom: 10px;
                display: block;
            }

            nav a {
                width: 100%;
                text-align: center;
            }

            section {
                padding: 20px;
            }

            pre {
                font-size: 0.85em;
            }
        }

        /* Feature List */
        .feature-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .feature-item {
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border-radius: 8px;
            text-align: center;
            font-weight: 600;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        /* Tabs */
        .tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin: 20px 0;
            border-bottom: 2px solid var(--border-color);
        }

        .tab-button {
            padding: 10px 20px;
            background: white;
            border: 2px solid var(--border-color);
            border-bottom: none;
            border-radius: 5px 5px 0 0;
            cursor: pointer;
            transition: all 0.3s ease;
            font-weight: 500;
        }

        .tab-button.active {
            background: var(--secondary-color);
            color: white;
            border-color: var(--secondary-color);
        }

        .tab-button:hover {
            background: var(--secondary-color);
            color: white;
        }

        .tab-content {
            display: none;
            padding: 20px;
            background: white;
        }

        .tab-content.active {
            display: block;
        }

        /* Timeline */
        .timeline {
            margin: 30px 0;
            position: relative;
            padding: 20px 0;
        }

        .timeline-item {
            margin-bottom: 25px;
            padding-left: 40px;
            position: relative;
        }

        .timeline-item::before {
            content: '';
            width: 15px;
            height: 15px;
            background: var(--secondary-color);
            border-radius: 50%;
            position: absolute;
            left: 0;
            top: 5px;
            box-shadow: 0 0 0 4px white, 0 0 0 8px var(--secondary-color);
        }

        .timeline-item h4 {
            margin-top: 0;
        }

        /* Comparison */
        .comparison-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }

        .comparison-item {
            padding: 20px;
            background: #f9f9f9;
            border-radius: 8px;
            border: 2px solid var(--border-color);
        }

        .comparison-item h4 {
            color: var(--secondary-color);
        }

        /* Footer */
        footer {
            background: var(--primary-color);
            color: white;
            text-align: center;
            padding: 30px;
            margin-top: 50px;
            border-radius: 10px;
            grid-column: 1 / -1;
        }

        /* Enhanced Mobile Navigation Button */
        .nav-toggle {
            display: none;
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            background: linear-gradient(135deg, var(--secondary-color) 0%, var(--info-color) 100%);
            color: white;
            border: none;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            z-index: 998;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
            transition: all 0.3s ease;
        }

        .nav-toggle:hover {
            transform: scale(1.1);
            box-shadow: 0 6px 20px rgba(0, 0, 0, 0.3);
        }

        @media (max-width: 768px) {
            .nav-toggle {
                display: none;
            }

            nav {
                position: sticky;
                left: auto;
                top: 0;
                width: 100%;
                max-height: none;
                z-index: 100;
                border-radius: 0;
                transform: none;
                transition: none;
                overflow-y: visible;
            }

            nav.show {
                transform: none;
            }
        }

        /* Print Styles */
        @media print {
            body {
                background: white;
            }

            section {
                page-break-inside: avoid;
                box-shadow: none;
            }

            nav {
                position: static;
            }
        }

        /* Animations */
        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        section {
            animation: fadeIn 0.6s ease;
        }

        /* Badge */
        .badge {
            display: inline-block;
            padding: 5px 12px;
            background: var(--secondary-color);
            color: white;
            border-radius: 20px;
            font-size: 0.85em;
            font-weight: 600;
            margin-right: 8px;
            margin-bottom: 8px;
        }

        .badge.success {
            background: var(--success-color);
        }

        .badge.warning {
            background: var(--warning-color);
        }

        .badge.info {
            background: var(--info-color);
        }

        /* Responsive Typography */
        @media (max-width: 480px) {
            header h1 {
                font-size: 1.3em;
            }

            header p {
                font-size: 0.85em;
            }

            h2 {
                font-size: 1.2em;
            }

            h3 {
                font-size: 1em;
            }

            nav h3 {
                font-size: 1em;
            }

            nav a {
                padding: 5px 10px;
                font-size: 0.85em;
            }

            .container {
                padding: 12px;
            }

            section {
                padding: 15px;
            }
        }

        /* Highlight Text */
        .highlight {
            background: #fff3cd;
            padding: 2px 6px;
            border-radius: 3px;
            font-weight: 600;
        }

        /* Link Styles */
        a {
            color: var(--secondary-color);
            text-decoration: none;
            transition: color 0.3s ease;
        }

        a:hover {
            color: var(--accent-color);
            text-decoration: underline;
        }

        /* Key Point Box */
        .key-point {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.2);
        }

        .key-point strong {
            display: block;
            margin-bottom: 8px;
            font-size: 1.1em;
        }

        /* Code Examples with Title */
        .code-example {
            margin: 20px 0;
        }

        .code-title {
            background: var(--secondary-color);
            color: white;
            padding: 10px 15px;
            border-radius: 5px 5px 0 0;
            font-weight: 600;
            font-size: 0.9em;
        }

        .code-example pre {
            border-radius: 0 0 5px 5px;
            margin: 0;
        }

        /* Searchable Content */
        .search-box {
            margin: 20px 0;
        }

        .search-box input {
            width: 100%;
            padding: 12px;
            border: 2px solid var(--border-color);
            border-radius: 5px;
            font-size: 1em;
            transition: border-color 0.3s ease;
        }

        .search-box input:focus {
            outline: none;
            border-color: var(--secondary-color);
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>üöÄ Web Apps Mastery: Complete Study Guide</h1>
            <p>Context Managers ‚Ä¢ Logging ‚Ä¢ Pydantic Data Validation</p>
            <p style="font-size: 0.9em; margin-top: 15px;">A Comprehensive, In-Depth Study Material for Production-Ready Python Web Applications</p>
        </header>

        <nav>
            <h3>üìö Quick Navigation</h3>
            <ul>
                <li><a href="#context-managers">Context Managers</a></li>
                <li><a href="#logging">Logging Systems</a></li>
                <li><a href="#pydantic">Pydantic Validation</a></li>
                <li><a href="#architecture">Architecture Patterns</a></li>
                <li><a href="#real-world">Real-World Implementation</a></li>
                <li><a href="#best-practices">Best Practices</a></li>
                <li><a href="#future">Future & Trends</a></li>
            </ul>
        </nav>

        <!-- PART 1: CONTEXT MANAGERS -->
        <section class="context-manager" id="context-managers">
            <h2>01. Context Managers: Resource Lifecycle Management</h2>

            <h3>üìñ What is a Context Manager?</h3>
            <div class="definition-box">
                <p><strong>Definition:</strong> A context manager is a Python protocol that defines a runtime context for a block of code. It ensures automatic cleanup of resources by executing <code>__enter__()</code> before a code block and <code>__exit__()</code> after‚Äîeven when exceptions occur.</p>
            </div>

            <p>Context managers are the backbone of safe resource management in Python web applications. They follow the <span class="highlight">acquire ‚Üí use ‚Üí release</span> pattern with guaranteed cleanup.</p>

            <h3>üéØ Why Use Context Managers?</h3>
            <div class="card-grid">
                <div class="card">
                    <h4>üõ°Ô∏è Safety & Reliability</h4>
                    <p>Prevents resource leaks (files, connections, sockets) even during exceptions. Guarantees cleanup through finally semantics.</p>
                </div>
                <div class="card">
                    <h4>üìù Readable Code</h4>
                    <p>Eliminates boilerplate try/finally blocks. Makes intent crystal clear: resources are managed for this block.</p>
                </div>
                <div class="card">
                    <h4>üîç Centralized Logic</h4>
                    <p>Acquisition and release logic lives in one place. Easy to audit and test.</p>
                </div>
                <div class="card">
                    <h4>‚è±Ô∏è Metrics & Tracing</h4>
                    <p>Perfect for timing, logging scopes, performance metrics, and request tracing in web apps.</p>
                </div>
            </div>

            <h3>‚è∞ When to Use Context Managers?</h3>
            <ul>
                <li><strong>File I/O:</strong> <code>with open(file)</code> ‚Äî auto-close on exit</li>
                <li><strong>Database Sessions:</strong> <code>with session():</code> ‚Äî commit/rollback</li>
                <li><strong>Network Connections:</strong> Sockets, HTTP clients ‚Äî cleanup sockets</li>
                <li><strong>Transactions:</strong> <code>with db.transaction():</code> ‚Äî ACID guarantees</li>
                <li><strong>Locks & Mutexes:</strong> Thread synchronization scopes</li>
                <li><strong>Temporary State:</strong> Change env vars, cwd, or global config</li>
                <li><strong>Metrics & Spans:</strong> Timing blocks, tracing requests</li>
            </ul>

            <div class="key-point">
                <strong>üéì Core Principle:</strong>
                If something must be closed, undone, or cleaned up, use a context manager. The <code>with</code> statement is your contract: "I acquire here, and I promise to release."
            </div>

            <h3>üèóÔ∏è Architecture: How the <code>with</code> Statement Works</h3>
            <div class="diagram">
  Enter Block
    ‚Üì
 __enter__() executes
    ‚Üì
 Resource acquired
    ‚Üì
 >>> Code block runs <<<
    ‚Üì
 Exception? (maybe)
    ‚Üì
 __exit__() always runs
    ‚Üì
 Resource released/cleaned
    ‚Üì
 Exit Block (exception re-raised if needed)
            </div>

            <h3>üìã Core Concept: The Context Manager Protocol</h3>
            <p>A context manager implements two magic methods:</p>
            <div class="code-example">
                <div class="code-title">Python Context Manager Protocol</div>
                <pre><code>class ContextManager:
    def __enter__(self):
        """Called when entering 'with' block.
        Return the resource to bind to 'as' variable.
        """
        # Acquire resource
        return resource

    def __exit__(self, exc_type, exc_value, traceback):
        """Called when exiting 'with' block.
        Called even if exception occurs.
        
        Arguments:
        - exc_type: Exception class (or None if no exception)
        - exc_value: Exception instance (or None)
        - traceback: Traceback object (or None)
        
        Return:
        - True: Suppress the exception
        - False/None: Re-raise the exception (default)
        """
        # Release resource
        # Cleanup, close, rollback, etc.
        return False  # Re-raise if exception occurred</code></pre>
            </div>

            <h3>üí° Simple Example: File Handling</h3>
            <div class="code-example">
                <div class="code-title">Built-in File Context Manager</div>
                <pre><code>with open('data.txt', 'r', encoding='utf-8') as f:
    content = f.read()
    print(content)
# File is automatically closed here, even if exception occurs
# No need for f.close() or try/finally
</code></pre>
            </div>

            <h3>üèóÔ∏è Class-Based Context Managers</h3>

            <h4>Basic Timer Example</h4>
            <div class="code-example">
                <div class="code-title">Simple Timer Context Manager</div>
                <pre><code>import time

class Timer:
    def __init__(self, label: str):
        self.label = label
        self.t0 = None

    def __enter__(self):
        self.t0 = time.perf_counter()
        return self

    def __exit__(self, exc_type, exc_value, tb):
        elapsed_ms = (time.perf_counter() - self.t0) * 1000
        status = "ERROR" if exc_type else "OK"
        print(f"[{status}] {self.label}: {elapsed_ms:.1f} ms")
        return False  # Re-raise exceptions


# Usage
with Timer("database_query"):
    time.sleep(0.1)  # Simulate work

with Timer("api_call"):
    raise ValueError("Network error")
    # Will print "[ERROR] api_call: 0.5 ms" then re-raise

# Output:
# [OK] database_query: 100.1 ms
# [ERROR] api_call: 0.5 ms
# ValueError: Network error
</code></pre>
            </div>

            <h4>Advanced: Logging Scope Manager</h4>
            <div class="code-example">
                <div class="code-title">LogScope Context Manager for Request Tracking</div>
                <pre><code>import logging
import json
from datetime import datetime

log = logging.getLogger("app")

class LogScope:
    """Context manager for structured logging within a scope."""
    
    def __init__(self, event_name: str, **context):
        self.event_name = event_name
        self.context = context
        self.start_time = None

    def __enter__(self):
        self.start_time = datetime.utcnow()
        log.info(
            f"START: {self.event_name}",
            extra={"event": self.event_name, "status": "started", **self.context}
        )
        return self

    def __exit__(self, exc_type, exc_value, tb):
        duration_ms = (datetime.utcnow() - self.start_time).total_seconds() * 1000
        status = "error" if exc_type else "completed"
        
        log.log(
            logging.ERROR if exc_type else logging.INFO,
            f"END: {self.event_name}",
            extra={
                "event": self.event_name,
                "status": status,
                "duration_ms": duration_ms,
                "exception": exc_type.__name__ if exc_type else None,
                **self.context
            }
        )
        return False  # Re-raise exception


# Usage in FastAPI
from fastapi import FastAPI

app = FastAPI()

@app.post("/users")
async def create_user(user_data: dict):
    with LogScope("create_user", user_id=user_data.get("id")):
        # Your logic here
        pass
</code></pre>
            </div>

            <h3>üîÑ Generator-Based Context Managers: @contextmanager</h3>
            <p>For simpler contexts, use the <code>@contextmanager</code> decorator instead of defining a class:</p>

            <div class="code-example">
                <div class="code-title">Decorator-Based Context Manager</div>
                <pre><code>from contextlib import contextmanager
import os

@contextmanager
def temporary_env(var: str, value: str):
    """Temporarily change an environment variable."""
    old_value = os.environ.get(var)
    os.environ[var] = value
    try:
        yield value  # Give control back to 'with' block
    finally:
        # Restore original value
        if old_value is None:
            os.environ.pop(var, None)
        else:
            os.environ[var] = old_value


# Usage
@contextmanager
def db_transaction(session):
    """Manage DB transactions: commit or rollback."""
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()


# In your code
with temporary_env("APP_DEBUG", "1"):
    # Code here runs with APP_DEBUG=1
    print(os.environ["APP_DEBUG"])  # prints: 1
# Environment restored automatically

with db_transaction(db_session) as session:
    user = session.query(User).filter_by(id=1).first()
    user.email = "new@example.com"
    # Commits automatically if no exception
</code></pre>
            </div>

            <h3>‚ö° Async Context Managers</h3>
            <p>For async code, use <code>async with</code> and <code>__aenter__/__aexit__</code>:</p>

            <div class="code-example">
                <div class="code-title">Async Context Manager Pattern</div>
                <pre><code>import asyncio
import httpx

class AsyncResource:
    """Async context manager for HTTP client."""
    
    async def __aenter__(self):
        self.client = httpx.AsyncClient(timeout=10.0)
        await self.client.__aenter__()
        return self.client

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        await self.client.__aexit__(exc_type, exc_val, exc_tb)


# Or using decorator
from contextlib import asynccontextmanager

@asynccontextmanager
async def http_session():
    """Manage HTTP session lifecycle."""
    async with httpx.AsyncClient(timeout=10.0) as client:
        yield client


# Usage in FastAPI
from fastapi import FastAPI, Depends

app = FastAPI()

async def get_http_client():
    async with http_session() as client:
        yield client

@app.get("/proxy")
async def proxy(url: str, client: httpx.AsyncClient = Depends(get_http_client)):
    response = await client.get(url)
    return response.json()
</code></pre>
            </div>

            <h3>üåê Web App Use Cases: Context Managers in FastAPI</h3>

            <h4>Case 1: Request-Scoped Database Session</h4>
            <div class="code-example">
                <div class="code-title">Database Session Management</div>
                <pre><code>from contextlib import contextmanager
from sqlalchemy.orm import Session
from fastapi import FastAPI, Depends

@contextmanager
def get_db_session(SessionLocal):
    """Manage database session lifecycle."""
    session = SessionLocal()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()


def get_session(SessionLocal):
    """FastAPI dependency."""
    with get_db_session(SessionLocal) as session:
        yield session


app = FastAPI()

@app.post("/users")
async def create_user(user_data: dict, db: Session = Depends(get_session)):
    new_user = User(**user_data)
    db.add(new_user)
    db.flush()  # Commits automatically when context exits
    return {"id": new_user.id, "email": new_user.email}
</code></pre>
            </div>

            <h4>Case 2: Request Timing & Logging Middleware</h4>
            <div class="code-example">
                <div class="code-title">Middleware with Timing Context Manager</div>
                <pre><code>import time
from contextlib import contextmanager
from starlette.middleware.base import BaseHTTPMiddleware

@contextmanager
def time_block(label: str):
    """Time a block of code and log results."""
    start = time.perf_counter()
    try:
        yield
    finally:
        elapsed_ms = (time.perf_counter() - start) * 1000
        print(f"{label}: {elapsed_ms:.1f} ms")


class TimingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        with time_block(f"{request.method} {request.url.path}"):
            response = await call_next(request)
        return response


app = FastAPI()
app.add_middleware(TimingMiddleware)
</code></pre>
            </div>

            <h4>Case 3: Transaction Management</h4>
            <div class="code-example">
                <div class="code-title">ACID Transaction Wrapper</div>
                <pre><code>@contextmanager
def transaction(engine):
    """Manage ACID transactions."""
    connection = engine.connect()
    transaction = connection.begin()
    try:
        yield connection
        transaction.commit()
    except Exception:
        transaction.rollback()
        raise
    finally:
        connection.close()


# Usage
@app.post("/transfer")
async def transfer_money(from_user: int, to_user: int, amount: float):
    with transaction(engine) as conn:
        # Both queries execute in same transaction
        conn.execute("UPDATE users SET balance = balance - :amt WHERE id = :user",
                    {"amt": amount, "user": from_user})
        conn.execute("UPDATE users SET balance = balance + :amt WHERE id = :user",
                    {"amt": amount, "user": to_user})
        # Commits automatically if no exception
</code></pre>
            </div>

            <h3>üîß Advanced: ExitStack & ContextDecorator</h3>

            <h4>ExitStack: Dynamic Resource Management</h4>
            <div class="code-example">
                <div class="code-title">ExitStack for Multiple Contexts</div>
                <pre><code>from contextlib import ExitStack

# Open multiple files and close them together
with ExitStack() as stack:
    files = [stack.enter_context(open(f, 'w')) for f in ['a.txt', 'b.txt', 'c.txt']]
    # All files will be closed together when exiting
    for f in files:
        f.write("content")


# Use case: Dynamic dependency injection
@contextmanager
def create_app_with_resources(*resource_factories):
    """Create app with dynamically loaded resources."""
    with ExitStack() as stack:
        resources = [stack.enter_context(factory()) for factory in resource_factories]
        yield resources
</code></pre>
            </div>

            <h3>‚öôÔ∏è Features & Capabilities</h3>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Capability</th>
                        <th>Use Case</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Resource Cleanup</td>
                        <td>Automatic release even on exceptions</td>
                        <td>Files, DB sessions, connections</td>
                    </tr>
                    <tr>
                        <td>Exception Handling</td>
                        <td>Full exception info in __exit__</td>
                        <td>Conditional cleanup based on error type</td>
                    </tr>
                    <tr>
                        <td>Metrics & Tracing</td>
                        <td>Time blocks, count events</td>
                        <td>Performance monitoring, request tracing</td>
                    </tr>
                    <tr>
                        <td>State Management</td>
                        <td>Restore state after block</td>
                        <td>Temp env vars, config changes</td>
                    </tr>
                    <tr>
                        <td>Async Support</td>
                        <td>__aenter__/__aexit__ protocol</td>
                        <td>Async I/O, concurrent operations</td>
                    </tr>
                </tbody>
            </table>

            <h3>‚úÖ Pros & ‚ùå Cons</h3>
            <div class="comparison-grid">
                <div class="comparison-item">
                    <h4>‚úÖ Advantages</h4>
                    <ul>
                        <li>Eliminates resource leaks</li>
                        <li>Clear, readable syntax</li>
                        <li>Guaranteed cleanup (even on exceptions)</li>
                        <li>Centralized acquisition/release logic</li>
                        <li>Perfect for timing and metrics</li>
                        <li>Works with async/await</li>
                    </ul>
                </div>
                <div class="comparison-item">
                    <h4>‚ùå Disadvantages</h4>
                    <ul>
                        <li>Only useful for resources with cleanup</li>
                        <li>Exception handling can be tricky</li>
                        <li>Nested contexts can get complex</li>
                        <li>Returning True in __exit__ silently suppresses exceptions</li>
                        <li>Not needed for simple, immutable objects</li>
                    </ul>
                </div>
            </div>

            <h3>üéØ Real-World Web App Implementation</h3>
            <div class="code-example">
                <div class="code-title">Complete FastAPI Example with Multiple Contexts</div>
                <pre><code>from fastapi import FastAPI, Depends
from contextlib import asynccontextmanager
import httpx
import time
from datetime import datetime

app = FastAPI()

# Logger context
@asynccontextmanager
async def request_scope(request_id: str):
    start = datetime.utcnow()
    print(f"[{request_id}] START")
    try:
        yield
    finally:
        duration = (datetime.utcnow() - start).total_seconds()
        print(f"[{request_id}] END ({duration:.2f}s)")


# HTTP client context
@asynccontextmanager
async def http_client_cm(timeout: float = 5.0):
    async with httpx.AsyncClient(timeout=timeout) as client:
        yield client


# Middleware using context
from starlette.middleware.base import BaseHTTPMiddleware
import uuid

class ContextMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        request_id = str(uuid.uuid4())[:8]
        async with request_scope(request_id):
            response = await call_next(request)
            response.headers["X-Request-ID"] = request_id
            return response


app.add_middleware(ContextMiddleware)


# Endpoint using HTTP client
@app.get("/fetch")
async def fetch_external(url: str):
    async with http_client_cm() as client:
        response = await client.get(url)
        return response.json()
</code></pre>
            </div>

            <h3>‚ö†Ô∏è Common Pitfalls & Anti-Patterns</h3>
            <ul>
                <li><strong>‚ùå Not using context managers:</strong> Manual try/finally everywhere</li>
                <li><strong>‚ùå Returning True in __exit__:</strong> Silently swallows exceptions‚Äîbad for debugging</li>
                <li><strong>‚ùå Long-running work in __exit__:</strong> Delays request/response cycle</li>
                <li><strong>‚ùå Mixing sync/async incorrectly:</strong> Use right variant (with vs async with)</li>
                <li><strong>‚ùå Over-nesting:</strong> Too many levels of context makes code hard to read</li>
            </ul>

        </section>

        <!-- PART 2: LOGGING -->
        <section class="logging" id="logging">
            <h2>02. Structured Logging: Observability & Debugging</h2>

            <h3>üìñ What is Logging?</h3>
            <div class="definition-box">
                <p><strong>Definition:</strong> Logging is the practice of recording application events in a structured, searchable format. For web apps, structured logs provide the single source of truth for debugging, auditing, and monitoring.</p>
            </div>

            <p>Modern logging is not just <code>print()</code> statements‚Äîit's a sophisticated observability layer that captures:</p>
            <ul>
                <li>Request/response lifecycle (method, path, status, latency)</li>
                <li>Business events (login, payment, data access)</li>
                <li>Errors and exceptions with full context</li>
                <li>Performance metrics (duration, query count)</li>
                <li>User actions and audit trails</li>
            </ul>

            <h3>üéØ Why Logging Matters</h3>
            <div class="card-grid">
                <div class="card">
                    <h4>üîç Debugging</h4>
                    <p>Rapidly diagnose production issues with structured context. Trace requests from entry to exit.</p>
                </div>
                <div class="card">
                    <h4>üìä Monitoring</h4>
                    <p>Track performance metrics, error rates, and user patterns over time.</p>
                </div>
                <div class="card">
                    <h4>üõ°Ô∏è Security & Audit</h4>
                    <p>Record all critical operations (auth, payments, data changes) for compliance and forensics.</p>
                </div>
                <div class="card">
                    <h4>üìà Analytics</h4>
                    <p>Analyze patterns, bottlenecks, and user behavior from log data.</p>
                </div>
            </div>

            <h3>‚è∞ When to Use Logging</h3>
            <ul>
                <li><strong>Always in production:</strong> Turn verbosity up/down by environment</li>
                <li><strong>Use INFO level:</strong> Lifecycle events, request start/end</li>
                <li><strong>Use ERROR level:</strong> Failures, exceptions, validation errors</li>
                <li><strong>Use DEBUG:</strong> Dev-time details (query strings, payloads)</li>
                <li><strong>Use structured format:</strong> JSON, not free-form text (for searchability)</li>
            </ul>

            <div class="key-point">
                <strong>üéì Core Principle:</strong>
                "If it's important enough to alert on or measure, it's important enough to log." Structure your logs so they're searchable, filterable, and actionable.
            </div>

            <h3>üèóÔ∏è Logging Architecture: The Pipeline</h3>
            <div class="diagram">
  Application Code
    ‚Üì
 logger.info("event", extra={...})
    ‚Üì
 Logger (named, hierarchical)
    ‚Üì
 Filter (drop, enrich)
    ‚Üì
 Formatter (text, JSON, custom)
    ‚Üì
 Handler (console, file, HTTP, syslog)
    ‚Üì
 Sink (stdout, file, Elasticsearch, CloudWatch)
    ‚Üì
 Storage/Analysis (Dashboard, Alerts)
            </div>

            <h3>üìã Core Concept: Logging Levels</h3>
            <table>
                <thead>
                    <tr>
                        <th>Level</th>
                        <th>When to Use</th>
                        <th>Example</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td><strong>DEBUG</strong> (10)</td>
                        <td>Verbose dev info</td>
                        <td>Query strings, variable values, internal flow</td>
                    </tr>
                    <tr>
                        <td><strong>INFO</strong> (20)</td>
                        <td>Lifecycle, milestones</td>
                        <td>Server started, request received, user logged in</td>
                    </tr>
                    <tr>
                        <td><strong>WARNING</strong> (30)</td>
                        <td>Unexpected but recoverable</td>
                        <td>Slow query, missing cache, rate limit approaching</td>
                    </tr>
                    <tr>
                        <td><strong>ERROR</strong> (40)</td>
                        <td>Failed operation</td>
                        <td>Request failed, database error, validation failed</td>
                    </tr>
                    <tr>
                        <td><strong>CRITICAL</strong> (50)</td>
                        <td>System unusable</td>
                        <td>Out of disk space, database unreachable</td>
                    </tr>
                </tbody>
            </table>

            <h3>üí° Setting Up Logging: Basic Config</h3>
            <div class="code-example">
                <div class="code-title">Basic Logging Setup</div>
                <pre><code>import logging
import logging.config

# Simple approach
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

logger = logging.getLogger(__name__)
logger.info("Application started")


# Production approach: DictConfig
LOGGING_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "simple": {
            "format": "%(asctime)s %(levelname)s %(name)s | %(message)s",
            "datefmt": "%Y-%m-%d %H:%M:%S"
        },
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "simple",
            "level": "INFO"
        },
    },
    "loggers": {
        "app": {
            "handlers": ["console"],
            "level": "INFO",
            "propagate": False
        }
    }
}

logging.config.dictConfig(LOGGING_CONFIG)
logger = logging.getLogger("app")
logger.info("App configured")
</code></pre>
            </div>

            <h3>üé® Structured Logging: JSON Format</h3>
            <p>Structured logs are machine-parsable and searchable in ELK/Datadog/CloudWatch:</p>

            <div class="code-example">
                <div class="code-title">JSON Structured Logging</div>
                <pre><code>from pythonjsonlogger import jsonlogger
import logging
import sys

# Setup JSON logging
handler = logging.StreamHandler(sys.stdout)
formatter = jsonlogger.JsonFormatter()
handler.setFormatter(formatter)

logger = logging.getLogger("app")
logger.setLevel(logging.INFO)
logger.addHandler(handler)

# Emit structured logs
logger.info("user_login", extra={
    "user_id": 123,
    "email": "user@example.com",
    "ip_address": "192.168.1.1",
    "timestamp": "2025-12-12T10:30:00Z"
})

# Output (single line JSON):
# {"message": "user_login", "user_id": 123, "email": "user@example.com", 
#  "ip_address": "192.168.1.1", "timestamp": "2025-12-12T10:30:00Z"}

# This is searchable! Try in Elasticsearch:
# GET logs/_search
# {
#   "query": {
#     "match": {"user_id": 123}
#   }
# }
</code></pre>
            </div>

            <h3>üåê Web App Integration: FastAPI Logging</h3>

            <h4>Step 1: Logging Configuration</h4>
            <div class="code-example">
                <div class="code-title">app/logging_config.py</div>
                <pre><code>import logging.config
from pythonjsonlogger import jsonlogger

LOGGING_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "json": {
            "()": jsonlogger.JsonFormatter,
            "fmt": "asctime level name message request_id user_id path method status latency_ms"
        },
        "simple": {
            "format": "%(asctime)s %(levelname)s %(name)s | %(message)s"
        }
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "json",
            "level": "INFO",
            "stream": "ext://sys.stdout"
        }
    },
    "loggers": {
        "app": {
            "handlers": ["console"],
            "level": "INFO",
            "propagate": False
        },
        "uvicorn.access": {
            "handlers": ["console"],
            "level": "INFO",
            "propagate": False
        }
    }
}

def setup_logging():
    logging.config.dictConfig(LOGGING_CONFIG)
</code></pre>
            </div>

            <h4>Step 2: Request Middleware for Correlation</h4>
            <div class="code-example">
                <div class="code-title">app/middlewares.py</div>
                <pre><code>import time
import uuid
import logging
from starlette.middleware.base import BaseHTTPMiddleware

logger = logging.getLogger("app")

class AccessLogMiddleware(BaseHTTPMiddleware):
    """Log all requests with timing and status."""
    
    async def dispatch(self, request, call_next):
        # Generate request ID for tracing
        request_id = request.headers.get("X-Request-ID", str(uuid.uuid4())[:8])
        start_time = time.perf_counter()
        
        # Store in request state for downstream handlers
        request.state.request_id = request_id
        
        # Process request
        response = await call_next(request)
        
        # Calculate latency
        latency_ms = int((time.perf_counter() - start_time) * 1000)
        
        # Extract user info (if available after auth)
        user_id = getattr(request.state, "user_id", None)
        
        # Log structured data
        logger.info(
            "request_completed",
            extra={
                "request_id": request_id,
                "path": request.url.path,
                "method": request.method,
                "status": response.status_code,
                "latency_ms": latency_ms,
                "user_id": user_id,
                "client_ip": request.client.host if request.client else None
            }
        )
        
        # Add request ID to response
        response.headers["X-Request-ID"] = request_id
        return response


class ErrorLogMiddleware(BaseHTTPMiddleware):
    """Log exceptions with full context."""
    
    async def dispatch(self, request, call_next):
        try:
            response = await call_next(request)
            return response
        except Exception as e:
            request_id = getattr(request.state, "request_id", str(uuid.uuid4())[:8])
            logger.error(
                "request_error",
                extra={
                    "request_id": request_id,
                    "path": request.url.path,
                    "method": request.method,
                    "error_type": type(e).__name__,
                    "error_message": str(e),
                    "user_id": getattr(request.state, "user_id", None)
                },
                exc_info=True  # Include full traceback
            )
            raise
</code></pre>
            </div>

            <h4>Step 3: Wire it into FastAPI</h4>
            <div class="code-example">
                <div class="code-title">main.py</div>
                <pre><code>from fastapi import FastAPI
from app.logging_config import setup_logging
from app.middlewares import AccessLogMiddleware, ErrorLogMiddleware
import logging

# Setup logging first
setup_logging()
logger = logging.getLogger("app")

app = FastAPI()

# Add middleware in reverse order (bottom middleware is first)
app.add_middleware(ErrorLogMiddleware)
app.add_middleware(AccessLogMiddleware)

@app.on_event("startup")
async def startup():
    logger.info("app_startup", extra={"version": "1.0.0"})

@app.get("/health")
async def health():
    logger.debug("health_check", extra={"status": "ok"})
    return {"status": "ok"}

@app.post("/orders")
async def create_order(order_data: dict):
    logger.info(
        "order_created",
        extra={
            "order_id": order_data.get("id"),
            "amount": order_data.get("amount"),
            "customer_id": order_data.get("customer_id")
        }
    )
    return {"ok": True, "order_id": order_data.get("id")}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
</code></pre>
            </div>

            <h3>üîë Correlation IDs: Tracing Requests</h3>
            <p>Use ContextVars to track request context across async boundaries:</p>

            <div class="code-example">
                <div class="code-title">Context Variables for Tracing</div>
                <pre><code>from contextvars import ContextVar

# Define context variables
request_id_var = ContextVar("request_id", default=None)
user_id_var = ContextVar("user_id", default=None)

# In middleware
async def dispatch(self, request, call_next):
    rid = str(uuid.uuid4())[:8]
    request_id_var.set(rid)
    
    # ... process request ...
    
    # Set user_id after auth
    request.state.user_id = 42
    user_id_var.set(42)
    
    response = await call_next(request)
    return response


# In any handler/service, automatically have context
logger.info("payment_processed", extra={
    "request_id": request_id_var.get(),
    "user_id": user_id_var.get(),
    "amount": 99.99
})

# Output includes request_id and user_id without passing them explicitly
</code></pre>
            </div>

            <h3>‚öôÔ∏è Features & Capabilities</h3>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Capability</th>
                        <th>Benefit</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Structured Format</td>
                        <td>JSON, key-value pairs</td>
                        <td>Searchable, parseable by tools</td>
                    </tr>
                    <tr>
                        <td>Log Levels</td>
                        <td>DEBUG, INFO, WARNING, ERROR, CRITICAL</td>
                        <td>Filter logs by severity</td>
                    </tr>
                    <tr>
                        <td>Handlers</td>
                        <td>Console, File, HTTP, Email, Syslog</td>
                        <td>Route logs to different sinks</td>
                    </tr>
                    <tr>
                        <td>Formatters</td>
                        <td>Custom formats, JSON, etc.</td>
                        <td>Control output format</td>
                    </tr>
                    <tr>
                        <td>Filters</td>
                        <td>Redact, enrich, drop logs</td>
                        <td>Security, PII masking</td>
                    </tr>
                    <tr>
                        <td>Rotation</td>
                        <td>Time/size-based rotation</td>
                        <td>Manage disk space</td>
                    </tr>
                </tbody>
            </table>

            <h3>‚úÖ Pros & ‚ùå Cons</h3>
            <div class="comparison-grid">
                <div class="comparison-item">
                    <h4>‚úÖ Advantages</h4>
                    <ul>
                        <li>Centralized observability</li>
                        <li>Easy to search/filter (JSON)</li>
                        <li>Audit trail for compliance</li>
                        <li>Performance metrics built-in</li>
                        <li>Works across async code</li>
                        <li>Flexible routing to sinks</li>
                    </ul>
                </div>
                <div class="comparison-item">
                    <h4>‚ùå Disadvantages</h4>
                    <ul>
                        <li>Disk space if not rotated</li>
                        <li>PII/secrets can be logged by mistake</li>
                        <li>Overhead if logging everywhere</li>
                        <li>Wrong level = noise or missing info</li>
                        <li>Inconsistent schema = hard to search</li>
                    </ul>
                </div>
            </div>

            <h3>üõ°Ô∏è Security: Redaction & PII Masking</h3>
            <div class="code-example">
                <div class="code-title">Redact Sensitive Data</div>
                <pre><code>import logging
import re

class RedactionFilter(logging.Filter):
    """Redact sensitive data from logs."""
    
    # Patterns to redact
    PATTERNS = {
        "password": r"password['\"]?\s*[:=]\s*['\"]?([^'\"]*)['\"]?",
        "token": r"(token|api[_-]?key)['\"]?\s*[:=]\s*['\"]?([^'\"]*)['\"]?",
        "ssn": r"\b\d{3}-\d{2}-\d{4}\b",
        "credit_card": r"\b\d{4}[\s-]?\d{4}[\s-]?\d{4}[\s-]?\d{4}\b",
        "email": r"\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b",
    }
    
    def filter(self, record):
        message = record.getMessage()
        
        # Redact each pattern
        for pattern_type, pattern in self.PATTERNS.items():
            message = re.sub(pattern, f"***[{pattern_type}]***", message)
        
        # Update record
        record.msg = message
        record.args = ()
        
        return True


# Add filter to handler
handler = logging.StreamHandler()
handler.addFilter(RedactionFilter())

logger = logging.getLogger("app")
logger.addHandler(handler)

# Usage
logger.info("user_login", extra={
    "user": "john@example.com",
    "password": "MySecret123",
    "token": "sk_live_abcd1234"
})

# Output: user field redacted, password and token masked
</code></pre>
            </div>

            <h3>üìä Real-World: Complete Logging System</h3>
            <div class="code-example">
                <div class="code-title">Production-Ready Logging Setup</div>
                <pre><code>"""
Complete logging system for FastAPI application.
Combines structured logs, request tracing, and security.
"""

import logging.config
import logging.handlers
import time
import uuid
from contextvars import ContextVar
from pythonjsonlogger import jsonlogger
from fastapi import FastAPI, Request
from starlette.middleware.base import BaseHTTPMiddleware

# Context variables for request tracing
request_id_var = ContextVar("request_id", default=None)
user_id_var = ContextVar("user_id", default=None)

LOGGING_CONFIG = {
    "version": 1,
    "disable_existing_loggers": False,
    "formatters": {
        "json": {
            "()": jsonlogger.JsonFormatter,
            "fmt": "timestamp level name message"
        },
        "simple": {
            "format": "%(asctime)s [%(levelname)s] %(name)s: %(message)s"
        }
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "level": "INFO",
            "formatter": "json",
            "stream": "ext://sys.stdout"
        },
        "file": {
            "class": "logging.handlers.RotatingFileHandler",
            "filename": "logs/app.log",
            "maxBytes": 10_000_000,  # 10 MB
            "backupCount": 10,
            "formatter": "json",
            "level": "DEBUG"
        }
    },
    "loggers": {
        "app": {
            "handlers": ["console", "file"],
            "level": "INFO",
            "propagate": False
        }
    }
}

def setup_logging():
    logging.config.dictConfig(LOGGING_CONFIG)

app = FastAPI()

class RequestLoggingMiddleware(BaseHTTPMiddleware):
    async def dispatch(self, request: Request, call_next):
        # Setup context
        rid = str(uuid.uuid4())[:8]
        request_id_var.set(rid)
        
        request.state.request_id = rid
        start = time.perf_counter()
        
        try:
            response = await call_next(request)
            
            # Log successful request
            latency_ms = int((time.perf_counter() - start) * 1000)
            
            logger = logging.getLogger("app")
            logger.info(
                "request_processed",
                extra={
                    "request_id": rid,
                    "method": request.method,
                    "path": request.url.path,
                    "status": response.status_code,
                    "latency_ms": latency_ms,
                    "user_id": user_id_var.get(),
                    "ip": request.client.host if request.client else None
                }
            )
            
            response.headers["X-Request-ID"] = rid
            return response
            
        except Exception as e:
            latency_ms = int((time.perf_counter() - start) * 1000)
            
            logger = logging.getLogger("app")
            logger.error(
                "request_error",
                extra={
                    "request_id": rid,
                    "method": request.method,
                    "path": request.url.path,
                    "error": str(e),
                    "latency_ms": latency_ms,
                    "user_id": user_id_var.get()
                },
                exc_info=True
            )
            raise

setup_logging()
app.add_middleware(RequestLoggingMiddleware)

# Example endpoint
@app.get("/api/users/{user_id}")
async def get_user(user_id: int, request: Request):
    # Simulate user context
    user_id_var.set(user_id)
    
    logger = logging.getLogger("app")
    logger.info(
        "user_fetched",
        extra={"user_id": user_id, "request_id": request.state.request_id}
    )
    
    return {"id": user_id, "name": "John Doe"}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
</code></pre>
            </div>

        </section>

        <!-- PART 3: PYDANTIC -->
        <section class="pydantic" id="pydantic">
            <h2>03. Pydantic: Data Validation & Serialization</h2>

            <h3>üìñ What is Pydantic?</h3>
            <div class="definition-box">
                <p><strong>Definition:</strong> Pydantic is a Python library for data validation and serialization using standard type hints. It automatically validates input, coerces types, and generates JSON Schema‚Äîperfect for HTTP APIs.</p>
            </div>

            <p>In <strong>v2</strong>, Pydantic uses <code>pydantic-core</code> (written in Rust) for lightning-fast validation. Models are plain Python classes inheriting from <code>BaseModel</code>.</p>

            <h3>üéØ Why Use Pydantic?</h3>
            <div class="card-grid">
                <div class="card">
                    <h4>üõ°Ô∏è Validate Input</h4>
                    <p>Reject bad data at the edge. Return clear 422 errors. Never trust user input.</p>
                </div>
                <div class="card">
                    <h4>‚ö° Developer Speed</h4>
                    <p>Less boilerplate than manual validation. Define once, use everywhere (API, DB, UI).</p>
                </div>
                <div class="card">
                    <h4>üìã Type-Driven Design</h4>
                    <p>Single source of truth: models define shapes across your stack (client ‚Üî API ‚Üî DB).</p>
                </div>
                <div class="card">
                    <h4>üìö Auto Docs</h4>
                    <p>Pydantic generates JSON Schema, which FastAPI uses for interactive Swagger docs.</p>
                </div>
            </div>

            <h3>‚è∞ When to Use Pydantic</h3>
            <ul>
                <li><strong>HTTP APIs:</strong> Request/response bodies, query params, form data</li>
                <li><strong>Config Management:</strong> App settings from env vars (with pydantic-settings)</li>
                <li><strong>Data Integration:</strong> Convert between DTOs and ORM objects</li>
                <li><strong>Parsing:</strong> Sanitize third-party data (webhooks, CSV, message queues)</li>
            </ul>

            <div class="key-point">
                <strong>üéì Core Principle:</strong>
                "Trust nothing." Validate all external input. Pydantic is your gatekeeper between the untrusted outside world and your safe, typed domain.
            </div>

            <h3>üèóÔ∏è Data Validation Architecture</h3>
            <div class="diagram">
  Raw Input (JSON, form, query)
    ‚Üì
 Pydantic Model.model_validate()
    ‚Üì
 Type coercion (string "42" ‚Üí int 42)
    ‚Üì
 Field validators (@field_validator)
    ‚Üì
 Model validators (@model_validator)
    ‚Üì
 Validated Python object
    ‚Üì
 Or ‚Üí ValidationError with 422 details
            </div>

            <h3>üí° Basic Example: User Registration</h3>
            <div class="code-example">
                <div class="code-title">Simple Pydantic Model</div>
                <pre><code>from pydantic import BaseModel, EmailStr, Field
from typing import Optional

class UserSignUp(BaseModel):
    """User registration request."""
    name: str = Field(min_length=2, max_length=100, description="User full name")
    email: EmailStr  # Validates email format
    password: str = Field(min_length=8, description="Must be at least 8 chars")
    phone: Optional[str] = None  # Optional field


# Validate and create
payload = {
    "name": "Asha Kumar",
    "email": "asha@example.com",
    "password": "SecurePass123"
}

user = UserSignUp.model_validate(payload)
print(user)
# UserSignUp(name='Asha Kumar', email='asha@example.com', password='SecurePass123', phone=None)

# Serialize to JSON
print(user.model_dump_json())
# {"name":"Asha Kumar","email":"asha@example.com","password":"SecurePass123","phone":null}

# Invalid input ‚Üí ValidationError
try:
    bad_user = UserSignUp.model_validate({
        "name": "A",  # Too short
        "email": "invalid",  # Not an email
        "password": "weak"  # Too short
    })
except Exception as e:
    print(e)
    # Shows all validation errors with details
</code></pre>
            </div>

            <h3>üèóÔ∏è Core Concept: BaseModel & Fields</h3>

            <div class="code-example">
                <div class="code-title">Advanced Model Definition</div>
                <pre><code>from pydantic import BaseModel, Field, field_validator
from typing import Optional, List
from datetime import datetime
from enum import Enum

class Status(str, Enum):
    """User status enum."""
    active = "active"
    inactive = "inactive"
    pending = "pending"

class Address(BaseModel):
    """Nested model."""
    street: str
    city: str
    country: str
    postal_code: str = Field(pattern=r"^\d{5}(-\d{4})?$")  # ZIP/ZIP+4


class User(BaseModel):
    """Complete user profile."""
    id: int = Field(gt=0)  # gt = greater than 0
    name: str = Field(min_length=2, max_length=100)
    email: str
    age: int = Field(ge=0, le=150)  # ge/le = greater/less than or equal
    status: Status = Status.active
    address: Address  # Nested validation
    tags: List[str] = []  # Default empty list
    created_at: datetime = Field(default_factory=datetime.utcnow)
    is_verified: bool = False

    @field_validator("name")
    @classmethod
    def name_must_be_title_case(cls, v):
        if not v.istitle():
            raise ValueError("Name must be title case")
        return v

    class Config:
        # Pydantic v1 syntax; v2 uses model_config
        json_schema_extra = {
            "example": {
                "id": 1,
                "name": "John Doe",
                "email": "john@example.com",
                "age": 30,
                "status": "active"
            }
        }


# Usage
user_data = {
    "id": 1,
    "name": "John Doe",
    "email": "john@example.com",
    "age": 30,
    "address": {
        "street": "123 Main St",
        "city": "New York",
        "country": "USA",
        "postal_code": "10001"
    },
    "tags": ["premium", "verified"]
}

user = User.model_validate(user_data)
print(user)
print(user.address.city)  # "New York"
print(user.created_at)  # Current UTC time
</code></pre>
            </div>

            <h3>‚úÖ Validation: Field & Model Validators</h3>

            <div class="code-example">
                <div class="code-title">Custom Validation Logic</div>
                <pre><code>from pydantic import BaseModel, field_validator, model_validator

class PasswordChange(BaseModel):
    """Password change request."""
    old_password: str
    new_password: str
    confirm_password: str

    @field_validator("new_password")
    @classmethod
    def password_strong(cls, v: str):
        """Validate password strength."""
        if len(v) < 8:
            raise ValueError("Password must be at least 8 characters")
        if v.isalpha():
            raise ValueError("Password must contain numbers")
        if v.isdigit():
            raise ValueError("Password must contain letters")
        return v

    @model_validator(mode='after')
    def passwords_match(self):
        """Validate that new and confirm passwords match."""
        if self.new_password != self.confirm_password:
            raise ValueError("New passwords do not match")
        return self


# Valid case
try:
    pwd = PasswordChange(
        old_password="OldPass123",
        new_password="NewPass456",
        confirm_password="NewPass456"
    )
    print("Valid:", pwd)
except Exception as e:
    print("Error:", e)


# Invalid case
try:
    pwd = PasswordChange(
        old_password="OldPass123",
        new_password="weak",
        confirm_password="wrong"
    )
except Exception as e:
    print("Validation failed:", e)
</code></pre>
            </div>

            <h3>üîå FastAPI Integration</h3>

            <h4>Case 1: Request & Response Models</h4>
            <div class="code-example">
                <div class="code-title">FastAPI with Pydantic Models</div>
                <pre><code>from fastapi import FastAPI, HTTPException, status
from pydantic import BaseModel, EmailStr
from typing import List

app = FastAPI()

class UserCreate(BaseModel):
    """Request model for creating user."""
    name: str
    email: EmailStr
    password: str

class UserResponse(BaseModel):
    """Response model (public user data)."""
    id: int
    name: str
    email: str

    class Config:
        from_attributes = True  # Map ORM to Pydantic

@app.post("/users", response_model=UserResponse, status_code=201)
async def create_user(user: UserCreate) -> UserResponse:
    """
    Create a new user.
    
    - **name**: User full name
    - **email**: Valid email address
    - **password**: Secure password (not returned)
    """
    # Pydantic validates request body automatically
    # If invalid, FastAPI returns 422 with error details
    
    # Your code here
    new_user = {
        "id": 1,
        "name": user.name,
        "email": user.email,
        "password_hash": "hashed_password"
    }
    
    # Return public data (password excluded)
    return UserResponse(id=new_user["id"], name=new_user["name"], email=new_user["email"])


# Test:
# POST /users
# {
#   "name": "Asha Kumar",
#   "email": "asha@example.com",
#   "password": "SecurePass123"
# }
#
# Returns 201:
# {
#   "id": 1,
#   "name": "Asha Kumar",
#   "email": "asha@example.com"
# }
#
# Invalid email:
# Returns 422:
# {
#   "detail": [
#     {
#       "type": "value_error",
#       "loc": ["body", "email"],
#       "msg": "invalid email format"
#     }
#   ]
# }
</code></pre>
            </div>

            <h4>Case 2: Query Parameters & Pagination</h4>
            <div class="code-example">
                <div class="code-title">Validated Query Parameters</div>
                <pre><code>from fastapi import Query
from typing import Annotated

class PaginationParams(BaseModel):
    """Pagination request."""
    limit: Annotated[int, Query(ge=1, le=100)] = 20
    offset: Annotated[int, Query(ge=0)] = 0
    sort_by: str = "created_at"

@app.get("/items")
async def list_items(params: PaginationParams = Depends()):
    """
    List items with pagination.
    
    - **limit**: Results per page (1-100)
    - **offset**: Skip N results
    - **sort_by**: Field to sort by
    """
    # params automatically validated
    print(f"Limit: {params.limit}, Offset: {params.offset}")
    
    return {
        "total": 100,
        "limit": params.limit,
        "offset": params.offset,
        "items": []
    }

# Test:
# GET /items?limit=50&offset=10 ‚úì
# GET /items?limit=150 ‚úó Returns 422 (exceeds max 100)
# GET /items?offset=-5 ‚úó Returns 422 (negative offset)
</code></pre>
            </div>

            <h4>Case 3: Nested JSON Models</h4>
            <div class="code-example">
                <div class="code-title">Complex Nested Models</div>
                <pre><code>from typing import List
from pydantic import BaseModel

class OrderItem(BaseModel):
    """Item in an order."""
    sku: str
    quantity: int
    price: float

class Order(BaseModel):
    """Order with multiple items."""
    order_id: int
    customer_id: int
    items: List[OrderItem]
    total_amount: float = 0.0

    @model_validator(mode='after')
    def calculate_total(self):
        """Calculate total from items."""
        self.total_amount = sum(item.quantity * item.price for item in self.items)
        return self

@app.post("/orders")
async def create_order(order: Order):
    """
    Create an order.
    
    Request body:
    {
      "order_id": 1001,
      "customer_id": 42,
      "items": [
        {"sku": "ABC123", "quantity": 2, "price": 29.99},
        {"sku": "XYZ789", "quantity": 1, "price": 49.99}
      ]
    }
    """
    # Nested models automatically validated recursively
    print(f"Order total: {order.total_amount}")
    
    return {
        "success": True,
        "order_id": order.order_id,
        "total": order.total_amount
    }
</code></pre>
            </div>

            <h3>‚öôÔ∏è Features & Capabilities</h3>
            <table>
                <thead>
                    <tr>
                        <th>Feature</th>
                        <th>Capability</th>
                        <th>Benefit</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td>Type Validation</td>
                        <td>Enforce types, coerce when possible</td>
                        <td>Fail fast on wrong types</td>
                    </tr>
                    <tr>
                        <td>Constraints</td>
                        <td>min/max, regex patterns, custom validators</td>
                        <td>Business rule enforcement</td>
                    </tr>
                    <tr>
                        <td>Field Defaults</td>
                        <td>Default values, default_factory</td>
                        <td>Optional fields with sensible defaults</td>
                    </tr>
                    <tr>
                        <td>Nested Models</td>
                        <td>Recursive validation of nested objects</td>
                        <td>Complex data structures</td>
                    </tr>
                    <tr>
                        <td>JSON Schema</td>
                        <td>Automatic schema generation</td>
                        <td>API documentation, OpenAPI/Swagger</td>
                    </tr>
                    <tr>
                        <td>Serialization</td>
                        <td>model_dump, model_dump_json</td>
                        <td>Convert to dict/JSON for responses</td>
                    </tr>
                </tbody>
            </table>

            <h3>‚úÖ Pros & ‚ùå Cons</h3>
            <div class="comparison-grid">
                <div class="comparison-item">
                    <h4>‚úÖ Advantages</h4>
                    <ul>
                        <li>Zero boilerplate validation</li>
                        <li>Type hints are self-documenting</li>
                        <li>Fast (Rust backend in v2)</li>
                        <li>Auto-generates JSON Schema</li>
                        <li>Works great with FastAPI</li>
                        <li>Flexible validators</li>
                        <li>Version 2 is even faster</li>
                    </ul>
                </div>
                <div class="comparison-item">
                    <h4>‚ùå Disadvantages</h4>
                    <ul>
                        <li>Overhead for simple types (dataclass might be enough)</li>
                        <li>Learning curve for advanced validators</li>
                        <li>Version 1 ‚Üí 2 migration (some breaking changes)</li>
                        <li>Circular imports if not careful with models</li>
                        <li>Can be slow for very large objects</li>
                    </ul>
                </div>
            </div>

            <h3>üéØ Real-World: Complete E-Commerce API</h3>
            <div class="code-example">
                <div class="code-title">Production E-Commerce Models</div>
                <pre><code>from pydantic import BaseModel, EmailStr, Field, validator, model_validator
from typing import List, Optional
from enum import Enum
from datetime import datetime
from decimal import Decimal

class PaymentMethod(str, Enum):
    CARD = "card"
    UPI = "upi"
    WALLET = "wallet"

class OrderStatus(str, Enum):
    PENDING = "pending"
    CONFIRMED = "confirmed"
    SHIPPED = "shipped"
    DELIVERED = "delivered"
    CANCELLED = "cancelled"

class Address(BaseModel):
    """Delivery or billing address."""
    street_line1: str
    street_line2: Optional[str] = None
    city: str
    state: str
    postal_code: str = Field(pattern=r"^\d{5}(-\d{4})?$")
    country: str = "India"

class CartItem(BaseModel):
    """Item in shopping cart."""
    product_id: int = Field(gt=0)
    name: str = Field(min_length=1, max_length=255)
    quantity: int = Field(gt=0, le=999)
    price_per_unit: Decimal = Field(decimal_places=2)
    discount_percent: float = Field(ge=0, le=100, default=0)

    @property
    def subtotal(self) -> Decimal:
        """Calculate subtotal with discount."""
        discount = self.price_per_unit * (self.discount_percent / 100)
        return (self.price_per_unit - discount) * self.quantity

class Coupon(BaseModel):
    """Discount coupon."""
    code: str = Field(min_length=3, max_length=20)
    discount_percent: float = Field(ge=0, le=100)
    min_order_value: Decimal = Field(ge=0, decimal_places=2, default=0)
    max_uses: int = Field(gt=0, default=999)

class OrderCreate(BaseModel):
    """Create order request."""
    customer_id: int = Field(gt=0)
    items: List[CartItem] = Field(min_items=1)  # At least 1 item
    delivery_address: Address
    payment_method: PaymentMethod
    coupon_code: Optional[str] = None

    @model_validator(mode='after')
    def validate_order(self):
        """Cross-field validation."""
        total = sum(item.subtotal for item in self.items)
        if total < 100:
            raise ValueError("Minimum order value is ‚Çπ100")
        return self

class OrderResponse(BaseModel):
    """Order response (read-only)."""
    order_id: int
    customer_id: int
    status: OrderStatus
    items: List[CartItem]
    total_amount: Decimal
    delivery_address: Address
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True  # If using ORM

# FastAPI endpoint
@app.post("/orders", response_model=OrderResponse)
async def create_order(order: OrderCreate):
    """Create a new order with validation."""
    
    # Pydantic already validated:
    # - At least 1 item
    # - Valid addresses
    # - Valid payment method
    # - Minimum order value
    
    # Your business logic here
    order_id = 5001
    total = sum(item.subtotal for item in order.items)
    
    return OrderResponse(
        order_id=order_id,
        customer_id=order.customer_id,
        status=OrderStatus.PENDING,
        items=order.items,
        total_amount=total,
        delivery_address=order.delivery_address,
        created_at=datetime.utcnow(),
        updated_at=datetime.utcnow()
    )

# Test payload:
# POST /orders
# {
#   "customer_id": 123,
#   "items": [
#     {
#       "product_id": 1,
#       "name": "Laptop",
#       "quantity": 1,
#       "price_per_unit": "89999.00",
#       "discount_percent": 10
#     }
#   ],
#   "delivery_address": {
#     "street_line1": "123 Main Street",
#     "city": "Bangalore",
#     "state": "Karnataka",
#     "postal_code": "560001",
#     "country": "India"
#   },
#   "payment_method": "upi"
# }
</code></pre>
            </div>

        </section>

        <!-- INTEGRATION SECTION -->
        <section id="architecture">
            <h2>04. üèóÔ∏è Architecture: Putting It All Together</h2>

            <h3>How These Three Pieces Work Together</h3>
            <div class="diagram">
User Request
    ‚Üì
[Middleware] Logging middleware logs request start (LogScope)
    ‚Üì
[Pydantic] Request body validated & parsed
    ‚Üì
[Context Manager] DB session acquired (with transaction)
    ‚Üì
[Your Logic] Handle business logic
    ‚Üì
[Context Manager] DB session committed/rolled back
    ‚Üì
[Pydantic] Response serialized to JSON
    ‚Üì
[Logging] Middleware logs request end with latency
    ‚Üì
Response sent to client
            </div>

            <h3>Complete FastAPI Application</h3>
            <div class="code-example">
                <div class="code-title">Integrated FastAPI App with All Three Concepts</div>
                <pre><code>"""
Complete web application using:
1. Context Managers for DB sessions
2. Structured Logging for observability
3. Pydantic for data validation
"""

from fastapi import FastAPI, Depends, HTTPException, status
from pydantic import BaseModel, EmailStr, Field
from sqlalchemy.orm import Session
from contextlib import contextmanager
import logging
import time
import uuid
from datetime import datetime

# ===== SETUP =====

# 1. Logging Setup
import logging.config
from pythonjsonlogger import jsonlogger

LOGGING_CONFIG = {
    "version": 1,
    "formatters": {
        "json": {
            "()": jsonlogger.JsonFormatter,
            "fmt": "timestamp level message request_id user_id"
        }
    },
    "handlers": {
        "console": {
            "class": "logging.StreamHandler",
            "formatter": "json"
        }
    },
    "loggers": {
        "app": {
            "handlers": ["console"],
            "level": "INFO"
        }
    }
}

logging.config.dictConfig(LOGGING_CONFIG)
logger = logging.getLogger("app")

# 2. Pydantic Models
class UserBase(BaseModel):
    name: str = Field(min_length=2, max_length=100)
    email: EmailStr

class UserCreate(UserBase):
    password: str = Field(min_length=8)

class UserResponse(UserBase):
    id: int
    created_at: datetime

    class Config:
        from_attributes = True

class ProductBase(BaseModel):
    name: str
    price: float = Field(gt=0)
    stock: int = Field(ge=0)

class ProductResponse(ProductBase):
    id: int

# 3. Context Manager for DB
@contextmanager
def db_session(SessionLocal):
    session = SessionLocal()
    try:
        yield session
        session.commit()
    except Exception:
        session.rollback()
        raise
    finally:
        session.close()

# 4. FastAPI App Setup
app = FastAPI(
    title="Complete Web App",
    description="Context Managers + Logging + Pydantic",
    version="1.0.0"
)

# Request tracking middleware
from starlette.middleware.base import BaseHTTPMiddleware

class RequestTracking(BaseHTTPMiddleware):
    async def dispatch(self, request, call_next):
        request_id = str(uuid.uuid4())[:8]
        start = time.perf_counter()
        
        try:
            response = await call_next(request)
            
            latency_ms = int((time.perf_counter() - start) * 1000)
            logger.info(
                "request_completed",
                extra={
                    "request_id": request_id,
                    "method": request.method,
                    "path": request.url.path,
                    "status": response.status_code,
                    "latency_ms": latency_ms
                }
            )
            
            response.headers["X-Request-ID"] = request_id
            return response
            
        except Exception as e:
            latency_ms = int((time.perf_counter() - start) * 1000)
            logger.error(
                "request_error",
                extra={
                    "request_id": request_id,
                    "method": request.method,
                    "path": request.url.path,
                    "error": str(e),
                    "latency_ms": latency_ms
                },
                exc_info=True
            )
            raise

app.add_middleware(RequestTracking)

# Dependency for DB
def get_db():
    # In real app, use SessionLocal from SQLAlchemy
    from sqlalchemy.orm import sessionmaker
    SessionLocal = sessionmaker()  # Configure with engine
    
    with db_session(SessionLocal) as session:
        yield session

# ===== ENDPOINTS =====

@app.on_event("startup")
async def startup():
    logger.info("app_startup", extra={"version": "1.0.0"})

@app.post("/users", response_model=UserResponse, status_code=201)
async def create_user(
    user: UserCreate,  # ‚Üê Pydantic validation
    db: Session = Depends(get_db)  # ‚Üê Context manager
):
    """
    Create a new user.
    
    Validation (Pydantic):
    - name: 2-100 characters
    - email: valid email
    - password: min 8 characters
    
    Database (Context Manager):
    - Session automatically committed
    - Rolls back on error
    """
    logger.info(
        "user_creation_started",
        extra={"email": user.email}
    )
    
    # Your logic here
    new_user = {
        "id": 1,
        "name": user.name,
        "email": user.email,
        "created_at": datetime.utcnow()
    }
    
    logger.info(
        "user_created",
        extra={"user_id": new_user["id"], "email": user.email}
    )
    
    return new_user

@app.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: int = Field(gt=0),  # ‚Üê Pydantic validation
    db: Session = Depends(get_db)  # ‚Üê Context manager
):
    """Get user by ID."""
    # Your logic here
    user = {"id": user_id, "name": "John", "email": "john@example.com", "created_at": datetime.utcnow()}
    
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    return user

@app.post("/products", response_model=ProductResponse, status_code=201)
async def create_product(
    product: ProductBase,  # ‚Üê Pydantic validation
    db: Session = Depends(get_db)  # ‚Üê Context manager
):
    """Create a new product."""
    
    logger.info(
        "product_created",
        extra={"product_name": product.name, "price": product.price}
    )
    
    return {"id": 1, **product.dict()}

if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
</code></pre>
            </div>

        </section>

        <!-- BEST PRACTICES -->
        <section id="best-practices">
            <h2>05. üéØ Best Practices & Design Patterns</h2>

            <h3>1. Error Handling Across All Three</h3>
            <div class="code-example">
                <div class="code-title">Comprehensive Error Handling</div>
                <pre><code>from fastapi import FastAPI, HTTPException
from pydantic import ValidationError
from starlette.responses import JSONResponse

app = FastAPI()

@app.exception_handler(ValidationError)
async def validation_exception_handler(request, exc):
    """Handle Pydantic validation errors."""
    logger.error(
        "validation_error",
        extra={
            "errors": exc.errors(),
            "path": request.url.path
        }
    )
    return JSONResponse(
        status_code=422,
        content={"detail": exc.errors()}
    )

@app.exception_handler(Exception)
async def general_exception_handler(request, exc):
    """Handle unexpected errors."""
    request_id = str(uuid.uuid4())[:8]
    
    logger.error(
        "unhandled_exception",
        extra={
            "request_id": request_id,
            "error_type": type(exc).__name__,
            "path": request.url.path
        },
        exc_info=True
    )
    
    return JSONResponse(
        status_code=500,
        content={
            "detail": "Internal server error",
            "request_id": request_id
        }
    )
</code></pre>
            </div>

            <h3>2. Testing with All Three</h3>
            <div class="code-example">
                <div class="code-title">Test Strategy</div>
                <pre><code>import pytest
from fastapi.testclient import TestClient

client = TestClient(app)

def test_create_user_valid():
    """Test valid user creation."""
    response = client.post("/users", json={
        "name": "John Doe",
        "email": "john@example.com",
        "password": "SecurePass123"
    })
    
    assert response.status_code == 201
    assert response.json()["email"] == "john@example.com"

def test_create_user_invalid_email():
    """Test Pydantic validation."""
    response = client.post("/users", json={
        "name": "John",
        "email": "invalid-email",
        "password": "SecurePass123"
    })
    
    assert response.status_code == 422
    assert "email" in str(response.json())

def test_create_user_short_password():
    """Test field validation."""
    response = client.post("/users", json={
        "name": "John Doe",
        "email": "john@example.com",
        "password": "short"
    })
    
    assert response.status_code == 422

def test_db_rollback_on_error():
    """Test context manager rollback."""
    # Mock DB to raise error
    # Verify rollback is called
    pass
</code></pre>
            </div>

            <h3>3. Performance Optimization</h3>
            <ul>
                <li><strong>Cache validators:</strong> Avoid re-validating same data</li>
                <li><strong>Use TypeAdapter for lists:</strong> Faster than full models</li>
                <li><strong>Lazy loading:</strong> Don't validate fields you don't need</li>
                <li><strong>Connection pooling:</strong> Reuse DB sessions</li>
                <li><strong>Log sampling:</strong> Log 100% in dev, 10% in prod</li>
            </ul>

            <h3>4. Security Best Practices</h3>
            <ul>
                <li><strong>Never log secrets:</strong> Use RedactionFilter</li>
                <li><strong>Validate all input:</strong> Pydantic is mandatory</li>
                <li><strong>Type safety:</strong> Use strict types, not 'any'</li>
                <li><strong>Close resources:</strong> Always use context managers</li>
                <li><strong>Redact PII:</strong> Passwords, tokens, SSNs, credit cards</li>
            </ul>

        </section>

        <!-- FUTURE & TRENDS -->
        <section id="future">
            <h2>06. üöÄ Future & Emerging Trends</h2>

            <h3>Context Managers: Future Directions</h3>
            <ul>
                <li><strong>Structured Concurrency:</strong> Better async resource management</li>
                <li><strong>Type-Safe Context Vars:</strong> Typed context variables</li>
                <li><strong>Scope Injection:</strong> Automatic dependency scoping</li>
            </ul>

            <h3>Logging: Evolution</h3>
            <ul>
                <li><strong>OpenTelemetry:</strong> Unified logging, metrics, tracing (industry standard)</li>
                <li><strong>Structured Logging at Scale:</strong> CloudWatch, DataDog, Splunk native support</li>
                <li><strong>AI-Powered Analysis:</strong> LLMs analyzing logs for patterns and anomalies</li>
                <li><strong>Real-Time Dashboards:</strong> Live log streaming and alerting</li>
            </ul>

            <h3>Pydantic: Road Map</h3>
            <ul>
                <li><strong>v2 Maturation:</strong> Continued performance improvements (Rust backend)</li>
                <li><strong>Better IDE Support:</strong> Full type inference and autocomplete</li>
                <li><strong>Dynamic Schema Generation:</strong> More flexible JSON Schema</li>
                <li><strong>Integration with FastAPI 0.100+:</strong> Even tighter coupling</li>
            </ul>

            <h3>Convergence: These Three Will Dominate</h3>
            <p>As Python web frameworks evolve, these three patterns are becoming standard:</p>
            <ul>
                <li><strong>Context Managers:</strong> The only safe way to manage resources</li>
                <li><strong>Structured Logging:</strong> Observability becomes non-negotiable</li>
                <li><strong>Type-Driven Validation:</strong> Pydantic is the lingua franca of Python APIs</li>
            </ul>

        </section>

        <!-- REAL-WORLD SECTION -->
        <section id="real-world">
            <h2>07. üíº Real-World Production Implementation</h2>

            <h3>Case Study: E-Commerce Platform</h3>
            <p>How Netflix, Uber, and modern startups use these three patterns:</p>

            <div class="timeline">
                <div class="timeline-item">
                    <h4>üîπ Request Arrives</h4>
                    <p>User submits order. Request hits FastAPI endpoint.</p>
                </div>
                <div class="timeline-item">
                    <h4>üìä Logging: Request Starts</h4>
                    <p>Middleware logs request with request_id, user_id, path. Structured log to ELK.</p>
                </div>
                <div class="timeline-item">
                    <h4>‚úÖ Pydantic: Validation</h4>
                    <p>Request body validated. If invalid, return 422 with clear errors. Log validation error.</p>
                </div>
                <div class="timeline-item">
                    <h4>üîí Context Manager: DB Session</h4>
                    <p>Acquire database session. Start transaction. Ready for business logic.</p>
                </div>
                <div class="timeline-item">
                    <h4>üíº Business Logic</h4>
                    <p>Process order, create records, update inventory. All in transaction.</p>
                </div>
                <div class="timeline-item">
                    <h4>üíæ Context Manager: Commit</h4>
                    <p>Session context manager exits. Commits transaction automatically. Or rolls back if error.</p>
                </div>
                <div class="timeline-item">
                    <h4>‚úÖ Pydantic: Response</h4>
                    <p>Serialize response using Pydantic model. Excludes sensitive fields.</p>
                </div>
                <div class="timeline-item">
                    <h4>üìä Logging: Request Ends</h4>
                    <p>Middleware logs response. Status 200, latency 45ms. Structured log. All context attached (request_id, user_id).</p>
                </div>
                <div class="timeline-item">
                    <h4>üì§ Response Sent</h4>
                    <p>User receives valid JSON. Frontend renders. Logs searchable in Kibana/Datadog.</p>
                </div>
            </div>

            <h3>Deployment: Docker Container</h3>
            <div class="code-example">
                <div class="code-title">Docker + Gunicorn + Pydantic + Logging</div>
                <pre><code># Dockerfile
FROM python:3.11-slim

WORKDIR /app
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# Run with gunicorn (4 workers)
CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:8000", "--access-logfile", "-", "--error-logfile", "-", "main:app"]

---

# docker-compose.yml
version: '3.8'

services:
  app:
    build: .
    ports:
      - "8000:8000"
    environment:
      - APP_ENV=production
      - DATABASE_URL=postgresql://user:pass@db:5432/app
    depends_on:
      - db
      - elasticsearch

  db:
    image: postgres:15
    environment:
      - POSTGRES_PASSWORD=password

  elasticsearch:
    image: docker.elastic.co/elasticsearch/elasticsearch:8.0.0
    environment:
      - discovery.type=single-node

---

# requirements.txt
fastapi==0.104.1
uvicorn==0.24.0
pydantic==2.4.2
pydantic-settings==2.0.3
pythonjsonlogger==2.0.7
sqlalchemy==2.0.23
python-multipart==0.0.6
gunicorn==21.2.0
</code></pre>
            </div>

            <h3>Monitoring & Alerting</h3>
            <div class="code-example">
                <div class="code-title">OpenTelemetry for Observability</div>
                <pre><code>from opentelemetry import trace, metrics
from opentelemetry.exporter.otlp.proto.grpc.trace_exporter import OTLPSpanExporter
from opentelemetry.sdk.trace import TracerProvider
from opentelemetry.sdk.trace.export import BatchSpanProcessor

# Setup OTLP exporter (Jaeger, DataDog, etc.)
otlp_exporter = OTLPSpanExporter(otlp_endpoint="http://collector:4317")
trace.set_tracer_provider(TracerProvider())
trace.get_tracer_provider().add_span_processor(BatchSpanProcessor(otlp_exporter))

tracer = trace.get_tracer(__name__)

# Use in your code
with tracer.start_as_current_span("create_order") as span:
    span.set_attribute("order_id", order_id)
    span.set_attribute("user_id", user_id)
    
    # Your logic here
    # Automatically traced!

# Now you have:
# - Distributed tracing (request flow across services)
# - Performance metrics (latency by endpoint)
# - Error tracking (trace errors back to root cause)
</code></pre>
            </div>

        </section>

        <footer>
            <h3>üìö Complete Study Material Delivered</h3>
            <p><strong>Comprehensive Coverage:</strong> Context Managers ‚Ä¢ Logging Systems ‚Ä¢ Pydantic Validation</p>
            <p><strong>Production-Ready:</strong> Real-world examples, best practices, security patterns, deployment strategies</p>
            <p><strong>Interactive & Responsive:</strong> Works seamlessly on desktop, tablet, and mobile devices</p>
            <p style="margin-top: 20px; font-size: 0.9em;">Generated: December 12, 2025 | For Python Web Developers & Technical Leaders</p>
        </footer>
    </div>

    <script>
        // Smooth scroll for navigation links
        document.querySelectorAll('nav a').forEach(link => {
            link.addEventListener('click', function(e) {
                const href = this.getAttribute('href');
                if (href.startsWith('#')) {
                    e.preventDefault();
                    const target = document.querySelector(href);
                    if (target) {
                        target.scrollIntoView({ behavior: 'smooth' });
                    }
                }
            });
        });

        // Tab functionality (if implemented)
        function initTabs() {
            const tabButtons = document.querySelectorAll('.tab-button');
            tabButtons.forEach(button => {
                button.addEventListener('click', function() {
                    const tabGroup = this.parentElement;
                    const tabContents = tabGroup.parentElement.querySelectorAll('.tab-content');
                    
                    tabGroup.querySelectorAll('.tab-button').forEach(btn => {
                        btn.classList.remove('active');
                    });
                    tabContents.forEach(content => {
                        content.classList.remove('active');
                    });
                    
                    this.classList.add('active');
                    const contentId = this.getAttribute('data-tab');
                    document.getElementById(contentId).classList.add('active');
                });
            });
        }

        // Initialize on page load
        document.addEventListener('DOMContentLoaded', initTabs);

        // Dark mode toggle (optional)
        const darkModeToggle = document.createElement('button');
        darkModeToggle.textContent = 'üåô';
        darkModeToggle.style.cssText = 'position: fixed; bottom: 20px; right: 20px; padding: 10px 15px; background: #2c3e50; color: white; border: none; border-radius: 50%; cursor: pointer; z-index: 1000; font-size: 1.2em;';
        document.body.appendChild(darkModeToggle);

        darkModeToggle.addEventListener('click', function() {
            document.documentElement.setAttribute('data-theme', 
                document.documentElement.getAttribute('data-theme') === 'dark' ? 'light' : 'dark'
            );
        });

        // Copy code to clipboard
        document.querySelectorAll('pre').forEach(block => {
            const button = document.createElement('button');
            button.textContent = 'üìã Copy';
            button.style.cssText = 'position: absolute; top: 5px; right: 5px; padding: 5px 10px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer; font-size: 0.8em;';
            button.addEventListener('click', function() {
                const code = block.textContent;
                navigator.clipboard.writeText(code).then(() => {
                    button.textContent = '‚úÖ Copied!';
                    setTimeout(() => { button.textContent = 'üìã Copy'; }, 2000);
                });
            });
            block.parentElement.style.position = 'relative';
            block.parentElement.appendChild(button);
        });
    </script>
</body>
</html>
